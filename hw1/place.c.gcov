        -:    0:Source:SRC/place.c
        -:    0:Graph:OBJ/place.gcno
        -:    0:Data:OBJ/place.gcda
        -:    0:Runs:3
        -:    0:Programs:1
        -:    0:Source is newer than graph
        -:    1:/*#include <stdlib.h> */
        -:    2:#include <stdio.h>
        -:    3:#include <math.h>
        -:    4:#include <assert.h>
        -:    5:#include "util.h"
        -:    6:#include "vpr_types.h"
        -:    7:#include "globals.h"
        -:    8:#include "mst.h"
        -:    9:#include "place.h"
        -:   10:#include "read_place.h"
        -:   11:#include "draw.h"
        -:   12:#include "place_and_route.h"
        -:   13:#include "net_delay.h"
        -:   14:#include "path_delay.h"
        -:   15:#include "timing_place_lookup.h"
        -:   16:#include "timing_place.h"
        -:   17:#include "place_stats.h"
        -:   18:
        -:   19:/************** Types and defines local to place.c ***************************/
        -:   20:
        -:   21:#define SMALL_NET 4		/* Cut off for incremental bounding box updates. */
        -:   22:/* 4 is fastest -- I checked.                    */
        -:   23:
        -:   24:
        -:   25:/* For comp_cost.  NORMAL means use the method that generates updateable  *
        -:   26: * bounding boxes for speed.  CHECK means compute all bounding boxes from *
        -:   27: * scratch using a very simple routine to allow checks of the other       *
        -:   28: * costs.                                                                 */
        -:   29:
        -:   30:enum cost_methods
        -:   31:{ NORMAL, CHECK };
        -:   32:
        -:   33:#define FROM 0			/* What block connected to a net has moved? */
        -:   34:#define TO 1
        -:   35:#define FROM_AND_TO 2
        -:   36:
        -:   37:#define ERROR_TOL .0025
        -:   38:#define MAX_MOVES_BEFORE_RECOMPUTE 50000
        -:   39:
        -:   40:/********************** Variables local to place.c ***************************/
        -:   41:
        -:   42:/* [0..num_nets-1]  0 if net never connects to the same block more than  *
        -:   43: *  once, otherwise it gives the number of duplicate connections.        */
        -:   44:
        -:   45:static int *duplicate_pins;
        -:   46:
        -:   47:/* [0..num_nets-1][0..num_unique_blocks-1]  Contains a list of blocks with *
        -:   48: * no duplicated blocks for ONLY those nets that had duplicates.           */
        -:   49:
        -:   50:static int **unique_pin_list;
        -:   51:
        -:   52:/* Cost of a net, and a temporary cost of a net used during move assessment. */
        -:   53:
        -:   54:static float *net_cost = NULL, *temp_net_cost = NULL;	/* [0..num_nets-1] */
        -:   55:
        -:   56:/* [0..num_nets-1][1..num_pins-1]. What is the value of the timing   */
        -:   57:/* driven portion of the cost function. These arrays will be set to  */
        -:   58:/* (criticality * delay) for each point to point connection. */
        -:   59:static float **point_to_point_timing_cost = NULL;
        -:   60:static float **temp_point_to_point_timing_cost = NULL;
        -:   61:
        -:   62:
        -:   63:
        -:   64:/* [0..num_nets-1][1..num_pins-1]. What is the value of the delay */
        -:   65:/* for each connection in the circuit */
        -:   66:static float **point_to_point_delay_cost = NULL;
        -:   67:static float **temp_point_to_point_delay_cost = NULL;
        -:   68:
        -:   69:
        -:   70:/* [0..num_blocks-1][0..pins_per_clb-1]. Indicates which pin on the net */
        -:   71:/* this block corresponds to, this is only required during timing-driven */
        -:   72:/* placement. It is used to allow us to update individual connections on */
        -:   73:/* each net */
        -:   74:static int **net_pin_index = NULL;
        -:   75:
        -:   76:
        -:   77:/* [0..num_nets-1].  Store the bounding box coordinates and the number of    *
        -:   78: * blocks on each of a net's bounding box (to allow efficient updates),      *
        -:   79: * respectively.                                                             */
        -:   80:
        -:   81:static struct s_bb *bb_coords = NULL, *bb_num_on_edges = NULL;
        -:   82:
        -:   83:/* Stores the maximum and expected occupancies, plus the cost, of each   *
        -:   84: * region in the placement.  Used only by the NONLINEAR_CONG cost        *
        -:   85: * function.  [0..num_region-1][0..num_region-1].  Place_region_x and    *
        -:   86: * y give the situation for the x and y directed channels, respectively. */
        -:   87:
        -:   88:static struct s_place_region **place_region_x, **place_region_y;
        -:   89:
        -:   90:/* Used only with nonlinear congestion.  [0..num_regions].            */
        -:   91:
        -:   92:static float *place_region_bounds_x, *place_region_bounds_y;
        -:   93:
        -:   94:/* The arrays below are used to precompute the inverse of the average   *
        -:   95: * number of tracks per channel between [subhigh] and [sublow].  Access *
        -:   96: * them as chan?_place_cost_fac[subhigh][sublow].  They are used to     *
        -:   97: * speed up the computation of the cost function that takes the length  *
        -:   98: * of the net bounding box in each dimension, divided by the average    *
        -:   99: * number of tracks in that direction; for other cost functions they    *
        -:  100: * will never be used.                                                  */
        -:  101:
        -:  102:static float **chanx_place_cost_fac, **chany_place_cost_fac;
        -:  103:
        -:  104:
        -:  105:/* Expected crossing counts for nets with different #'s of pins.  From *
        -:  106: * ICCAD 94 pp. 690 - 695 (with linear interpolation applied by me).   */
        -:  107:
        -:  108:static const float cross_count[50] = {	/* [0..49] */
        -:  109:    1.0, 1.0, 1.0, 1.0828, 1.1536, 1.2206, 1.2823, 1.3385, 1.3991, 1.4493,
        -:  110:    1.4974, 1.5455, 1.5937, 1.6418, 1.6899, 1.7304, 1.7709, 1.8114, 1.8519,
        -:  111:    1.8924,
        -:  112:    1.9288, 1.9652, 2.0015, 2.0379, 2.0743, 2.1061, 2.1379, 2.1698, 2.2016,
        -:  113:    2.2334,
        -:  114:    2.2646, 2.2958, 2.3271, 2.3583, 2.3895, 2.4187, 2.4479, 2.4772, 2.5064,
        -:  115:    2.5356,
        -:  116:    2.5610, 2.5864, 2.6117, 2.6371, 2.6625, 2.6887, 2.7148, 2.7410, 2.7671,
        -:  117:    2.7933
        -:  118:};
        -:  119:
        -:  120:
        -:  121:/********************* Static subroutines local to place.c *******************/
        -:  122:
        -:  123:static void alloc_and_load_unique_pin_list(void);
        -:  124:
        -:  125:static void free_unique_pin_list(void);
        -:  126:
        -:  127:static void alloc_place_regions(int num_regions);
        -:  128:
        -:  129:static void load_place_regions(int num_regions);
        -:  130:
        -:  131:static void free_place_regions(int num_regions);
        -:  132:
        -:  133:static void alloc_and_load_placement_structs(int place_cost_type,
        -:  134:					     int num_regions,
        -:  135:					     float place_cost_exp,
        -:  136:					     float ***old_region_occ_x,
        -:  137:					     float ***old_region_occ_y,
        -:  138:					     struct s_placer_opts
        -:  139:					     placer_opts);
        -:  140:
        -:  141:static void free_placement_structs(int place_cost_type,
        -:  142:				   int num_regions,
        -:  143:				   float **old_region_occ_x,
        -:  144:				   float **old_region_occ_y,
        -:  145:				   struct s_placer_opts placer_opts);
        -:  146:
        -:  147:static void alloc_and_load_for_fast_cost_update(float place_cost_exp);
        -:  148:
        -:  149:static void initial_placement(enum e_pad_loc_type pad_loc_type,
        -:  150:			      char *pad_loc_file);
        -:  151:
        -:  152:static float comp_bb_cost(int method,
        -:  153:			  int place_cost_type,
        -:  154:			  int num_regions);
        -:  155:
        -:  156:static int try_swap(float t,
        -:  157:		    float *cost,
        -:  158:		    float *bb_cost,
        -:  159:		    float *timing_cost,
        -:  160:		    float rlim,
        -:  161:		    int place_cost_type,
        -:  162:		    float **old_region_occ_x,
        -:  163:		    float **old_region_occ_y,
        -:  164:		    int num_regions,
        -:  165:		    boolean fixed_pins,
        -:  166:		    enum e_place_algorithm place_algorithm,
        -:  167:		    float timing_tradeoff,
        -:  168:		    float inverse_prev_bb_cost,
        -:  169:		    float inverse_prev_timing_cost,
        -:  170:		    float *delay_cost,
        -:  171:		    int *x_lookup);
        -:  172:
        -:  173:static void check_place(float bb_cost,
        -:  174:			float timing_cost,
        -:  175:			int place_cost_type,
        -:  176:			int num_regions,
        -:  177:			enum e_place_algorithm place_algorithm,
        -:  178:			float delay_cost);
        -:  179:
        -:  180:static float starting_t(float *cost_ptr,
        -:  181:			float *bb_cost_ptr,
        -:  182:			float *timing_cost_ptr,
        -:  183:			int place_cost_type,
        -:  184:			float **old_region_occ_x,
        -:  185:			float **old_region_occ_y,
        -:  186:			int num_regions,
        -:  187:			boolean fixed_pins,
        -:  188:			struct s_annealing_sched annealing_sched,
        -:  189:			int max_moves,
        -:  190:			float rlim,
        -:  191:			enum e_place_algorithm place_algorithm,
        -:  192:			float timing_tradeoff,
        -:  193:			float inverse_prev_bb_cost,
        -:  194:			float inverse_prev_timing_cost,
        -:  195:			float *delay_cost_ptr);
        -:  196:
        -:  197:
        -:  198:static void update_t(float *t,
        -:  199:		     float std_dev,
        -:  200:		     float rlim,
        -:  201:		     float success_rat,
        -:  202:		     struct s_annealing_sched annealing_sched);
        -:  203:
        -:  204:static void update_rlim(float *rlim,
        -:  205:			float success_rat);
        -:  206:
        -:  207:static int exit_crit(float t,
        -:  208:		     float cost,
        -:  209:		     struct s_annealing_sched annealing_sched);
        -:  210:
        -:  211:static int count_connections(void);
        -:  212:
        -:  213:static void compute_net_pin_index_values(void);
        -:  214:
        -:  215:static double get_std_dev(int n,
        -:  216:			  double sum_x_squared,
        -:  217:			  double av_x);
        -:  218:
        -:  219:static void free_fast_cost_update_structs(void);
        -:  220:
        -:  221:static float recompute_bb_cost(int place_cost_type,
        -:  222:			       int num_regions);
        -:  223:
        -:  224:static float comp_td_point_to_point_delay(int inet,
        -:  225:					  int ipin);
        -:  226:
        -:  227:static void update_td_cost(int b_from,
        -:  228:			   int b_to,
        -:  229:			   int num_of_pins);
        -:  230:
        -:  231:static void comp_delta_td_cost(int b_from,
        -:  232:			       int b_to,
        -:  233:			       int num_of_pins,
        -:  234:			       float *delta_timing,
        -:  235:			       float *delta_delay);
        -:  236:
        -:  237:static void comp_td_costs(float *timing_cost,
        -:  238:			  float *connection_delay_sum);
        -:  239:
        -:  240:static int assess_swap(float delta_c,
        -:  241:		       float t);
        -:  242:
        -:  243:static boolean find_to(int x_from,
        -:  244:		       int y_from,
        -:  245:		       t_type_ptr type,
        -:  246:		       float rlim,
        -:  247:		       int *x_lookup,
        -:  248:		       int *x_to,
        -:  249:		       int *y_to);
        -:  250:
        -:  251:static void get_non_updateable_bb(int inet,
        -:  252:				  struct s_bb *bb_coord_new);
        -:  253:
        -:  254:static void update_bb(int inet,
        -:  255:		      struct s_bb *bb_coord_new,
        -:  256:		      struct s_bb *bb_edge_new,
        -:  257:		      int xold,
        -:  258:		      int yold,
        -:  259:		      int xnew,
        -:  260:		      int ynew);
        -:  261:
        -:  262:static int find_affected_nets(int *nets_to_update,
        -:  263:			      int *net_block_moved,
        -:  264:			      int b_from,
        -:  265:			      int b_to,
        -:  266:			      int num_of_pins);
        -:  267:
        -:  268:static float get_net_cost(int inet,
        -:  269:			  struct s_bb *bb_ptr);
        -:  270:
        -:  271:static float nonlinear_cong_cost(int num_regions);
        -:  272:
        -:  273:static void update_region_occ(int inet,
        -:  274:			      struct s_bb *coords,
        -:  275:			      int add_or_sub,
        -:  276:			      int num_regions);
        -:  277:
        -:  278:static void save_region_occ(float **old_region_occ_x,
        -:  279:			    float **old_region_occ_y,
        -:  280:			    int num_regions);
        -:  281:
        -:  282:static void restore_region_occ(float **old_region_occ_x,
        -:  283:			       float **old_region_occ_y,
        -:  284:			       int num_regions);
        -:  285:
        -:  286:static void get_bb_from_scratch(int inet,
        -:  287:				struct s_bb *coords,
        -:  288:				struct s_bb *num_on_edges);
        -:  289:
        -:  290:static double get_net_wirelength_estimate(int inet,
        -:  291:					  struct s_bb *bbptr);
        -:  292:
        -:  293:/*****************************************************************************/
        -:  294:/* RESEARCH TODO: Bounding Box and rlim need to be redone for heterogeneous to prevent a QoR penalty */
        -:  295:void
function try_place called 2 returned 100% blocks executed 69%
        2:  296:try_place(struct s_placer_opts placer_opts,
        -:  297:	  struct s_annealing_sched annealing_sched,
        -:  298:	  t_chan_width_dist chan_width_dist,
        -:  299:	  struct s_router_opts router_opts,
        -:  300:	  struct s_det_routing_arch det_routing_arch,
        -:  301:	  t_segment_inf * segment_inf,
        -:  302:	  t_timing_inf timing_inf,
        -:  303:	  t_subblock_data * subblock_data_ptr,
        -:  304:	  t_mst_edge *** mst)
        -:  305:{
        -:  306:
        -:  307:    /* Does almost all the work of placing a circuit.  Width_fac gives the   *
        -:  308:     * width of the widest channel.  Place_cost_exp says what exponent the   *
        -:  309:     * width should be taken to when calculating costs.  This allows a       *
        -:  310:     * greater bias for anisotropic architectures.  Place_cost_type          *
        -:  311:     * determines which cost function is used.  num_regions is used only     *
        -:  312:     * the place_cost_type is NONLINEAR_CONG.                                */
        -:  313:
        -:  314:
        -:  315:    int tot_iter, inner_iter, success_sum;
        -:  316:    int move_lim, moves_since_cost_recompute, width_fac;
        -:  317:    float t, success_rat, rlim, d_max, est_crit;
        -:  318:    float cost, timing_cost, bb_cost, new_bb_cost, new_timing_cost;
        -:  319:    float delay_cost, new_delay_cost, place_delay_value;
        -:  320:    float inverse_prev_bb_cost, inverse_prev_timing_cost;
        -:  321:    float oldt;
        -:  322:    double av_cost, av_bb_cost, av_timing_cost, av_delay_cost,
        -:  323:	sum_of_squares, std_dev;
        -:  324:    float **old_region_occ_x, **old_region_occ_y;
        -:  325:    char msg[BUFSIZE];
        -:  326:    boolean fixed_pins;		/* Can pads move or not? */
        -:  327:    int num_connections;
        -:  328:    int inet, ipin, outer_crit_iter_count, inner_crit_iter_count,
        -:  329:	inner_recompute_limit;
        -:  330:    float **net_slack, **net_delay;
        -:  331:    float crit_exponent;
        -:  332:    float first_rlim, final_rlim, inverse_delta_rlim;
        -:  333:    float **remember_net_delay_original_ptr;	/*used to free net_delay if it is re-assigned */
        -:  334:
        -:  335:    int *x_lookup;		/* Used to quickly determine valid swap columns */
        -:  336:
        -:  337:    /* Allocated here because it goes into timing critical code where each memory allocation is expensive */
        2:  338:    x_lookup = my_malloc(nx * sizeof(int));
call    0 returned 100%
        -:  339:
        2:  340:    remember_net_delay_original_ptr = NULL;	/*prevents compiler warning */
        -:  341:
        4:  342:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2:  343:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE ||
branch  0 never executed
branch  1 never executed
    #####:  344:       placer_opts.enable_timing_computations)
        -:  345:	{
        -:  346:	    /*do this before the initial placement to avoid messing up the initial placement */
        2:  347:	    alloc_lookups_and_criticalities(chan_width_dist,
call    0 returned 100%
        -:  348:					    router_opts,
        -:  349:					    det_routing_arch,
        -:  350:					    segment_inf,
        -:  351:					    timing_inf,
        -:  352:					    *subblock_data_ptr,
        -:  353:					    &net_delay, &net_slack);
        -:  354:
        2:  355:	    remember_net_delay_original_ptr = net_delay;
        -:  356:
        -:  357:	    /*#define PRINT_LOWER_BOUND */
        -:  358:#ifdef PRINT_LOWER_BOUND
        -:  359:	    /*print the crit_path, assuming delay between blocks that are*
        -:  360:	     *block_dist apart*/
        -:  361:
        -:  362:	    if(placer_opts.block_dist <= nx)
        -:  363:		place_delay_value =
        -:  364:		    delta_clb_to_clb[placer_opts.block_dist][0];
        -:  365:	    else if(placer_opts.block_dist <= ny)
        -:  366:		place_delay_value =
        -:  367:		    delta_clb_to_clb[0][placer_opts.block_dist];
        -:  368:	    else
        -:  369:		place_delay_value = delta_clb_to_clb[nx][ny];
        -:  370:
        -:  371:	    printf("\nLower bound assuming delay of %g\n", place_delay_value);
        -:  372:
        -:  373:	    load_constant_net_delay(net_delay, place_delay_value);
        -:  374:	    load_timing_graph_net_delays(net_delay);
        -:  375:	    d_max = load_net_slack(net_slack, 0);
        -:  376:
        -:  377:#ifdef CREATE_ECHO_FILES
        -:  378:	    print_critical_path("Placement_Lower_Bound.echo");
        -:  379:	    print_sink_delays("Placement_Lower_Bound_Sink_Delays.echo");
        -:  380:#endif /* CREATE_ECHO_FILES */
        -:  381:
        -:  382:	    /*also print sink delays assuming 0 delay between blocks, 
        -:  383:	     * this tells us how much logic delay is on each path */
        -:  384:
        -:  385:	    load_constant_net_delay(net_delay, 0);
        -:  386:	    load_timing_graph_net_delays(net_delay);
        -:  387:	    d_max = load_net_slack(net_slack, 0);
        -:  388:
        -:  389:#ifdef CREATE_ECHO_FILES
        -:  390:	    print_sink_delays("Placement_Logic_Sink_Delays.echo");
        -:  391:#endif /* CREATE_ECHO_FILES */
        -:  392:#endif
        -:  393:
        -:  394:	}
        -:  395:
        2:  396:    width_fac = placer_opts.place_chan_width;
        2:  397:    if(placer_opts.pad_loc_type == FREE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2:  398:	fixed_pins = FALSE;
        -:  399:    else
    #####:  400:	fixed_pins = TRUE;
        -:  401:
        2:  402:    init_chan(width_fac, chan_width_dist);
call    0 returned 100%
        -:  403:
        2:  404:    alloc_and_load_placement_structs(placer_opts.place_cost_type,
call    0 returned 100%
        -:  405:				     placer_opts.num_regions,
        -:  406:				     placer_opts.place_cost_exp,
        -:  407:				     &old_region_occ_x, &old_region_occ_y,
        -:  408:				     placer_opts);
        -:  409:
        2:  410:    initial_placement(placer_opts.pad_loc_type, placer_opts.pad_loc_file);
call    0 returned 100%
        2:  411:    init_draw_coords((float)width_fac);
call    0 returned 100%
        -:  412:
        -:  413:    /* Storing the number of pins on each type of block makes the swap routine *
        -:  414:     * slightly more efficient.                                                */
        -:  415:
        -:  416:    /* Gets initial cost and loads bounding boxes. */
        -:  417:
        4:  418:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        2:  419:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -:  420:	{
        2:  421:	    bb_cost = comp_bb_cost(NORMAL, placer_opts.place_cost_type,
call    0 returned 100%
        -:  422:				   placer_opts.num_regions);
        -:  423:
        2:  424:	    crit_exponent = placer_opts.td_place_exp_first;	/*this will be modified when rlim starts to change */
        -:  425:
        2:  426:	    compute_net_pin_index_values();
call    0 returned 100%
        -:  427:
        2:  428:	    num_connections = count_connections();
call    0 returned 100%
        2:  429:	    printf
call    0 returned 100%
        -:  430:		("\nThere are %d point to point connections in this circuit\n\n",
        -:  431:		 num_connections);
        -:  432:
        2:  433:	    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  434:		{
    #####:  435:		    for(inet = 0; inet < num_nets; inet++)
branch  0 never executed
branch  1 never executed
    #####:  436:			for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
branch  0 never executed
branch  1 never executed
    #####:  437:			    timing_place_crit[inet][ipin] = 0;	/*dummy crit values */
        -:  438:
    #####:  439:		    comp_td_costs(&timing_cost, &delay_cost);	/*first pass gets delay_cost, which is used 
call    0 never executed
        -:  440:								 * in criticality computations in the next call
        -:  441:								 * to comp_td_costs. */
    #####:  442:		    place_delay_value = delay_cost / num_connections;	/*used for computing criticalities */
    #####:  443:		    load_constant_net_delay(net_delay, place_delay_value);
call    0 never executed
        -:  444:
        -:  445:		}
        -:  446:	    else
        2:  447:		place_delay_value = 0;
        -:  448:
        -:  449:
        2:  450:	    if(placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  451:		{
        2:  452:		    net_delay = point_to_point_delay_cost;	/*this keeps net_delay up to date with      *
        -:  453:								 * *the same values that the placer is using  *
        -:  454:								 * *point_to_point_delay_cost is computed each*
        -:  455:								 * *time that comp_td_costs is called, and is *
        -:  456:								 * *also updated after any swap is accepted   */
        -:  457:		}
        -:  458:
        -:  459:
        2:  460:	    load_timing_graph_net_delays(net_delay);
call    0 returned 100%
        2:  461:	    d_max = load_net_slack(net_slack, 0);
call    0 returned 100%
        2:  462:	    load_criticalities(placer_opts, net_slack, d_max, crit_exponent);
call    0 returned 100%
        2:  463:	    outer_crit_iter_count = 1;
        -:  464:
        -:  465:	    /*now we can properly compute costs  */
        2:  466:	    comp_td_costs(&timing_cost, &delay_cost);	/*also puts proper values into point_to_point_delay_cost */
call    0 returned 100%
        -:  467:
        2:  468:	    inverse_prev_timing_cost = 1 / timing_cost;
        2:  469:	    inverse_prev_bb_cost = 1 / bb_cost;
        2:  470:	    cost = 1;		/*our new cost function uses normalized values of           */
        -:  471:	    /*bb_cost and timing_cost, the value of cost will be reset  */
        -:  472:	    /*to 1 at each temperature when *_TIMING_DRIVEN_PLACE is true */
        -:  473:	}
        -:  474:    else
        -:  475:	{			/*BOUNDING_BOX_PLACE */
    #####:  476:	    cost = bb_cost = comp_bb_cost(NORMAL, placer_opts.place_cost_type,
call    0 never executed
        -:  477:					  placer_opts.num_regions);
    #####:  478:	    timing_cost = 0;
    #####:  479:	    delay_cost = 0;
    #####:  480:	    place_delay_value = 0;
    #####:  481:	    outer_crit_iter_count = 0;
    #####:  482:	    num_connections = 0;
    #####:  483:	    d_max = 0;
    #####:  484:	    crit_exponent = 0;
        -:  485: list line
    #####:  486:	    inverse_prev_timing_cost = 0;	/*inverses not used */
    #####:  487:	    inverse_prev_bb_cost = 0;
        -:  488:	}
        -:  489:
        2:  490:    move_lim = (int)(annealing_sched.inner_num * pow(num_blocks, 1.3333));
        -:  491:
        2:  492:    if(placer_opts.inner_loop_recompute_divider != 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  493:	inner_recompute_limit = (int)(0.5 + (float)move_lim /
    #####:  494:				      (float)placer_opts.
        -:  495:				      inner_loop_recompute_divider);
        -:  496:    else			/*don't do an inner recompute */
        2:  497:	inner_recompute_limit = move_lim + 1;
        -:  498:
        -:  499:
        -:  500:    /* Sometimes I want to run the router with a random placement.  Avoid *
        -:  501:     * using 0 moves to stop division by 0 and 0 length vector problems,  *
        -:  502:     * by setting move_lim to 1 (which is still too small to do any       *
        -:  503:     * significant optimization).                                         */
        -:  504:
        2:  505:    if(move_lim <= 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  506:	move_lim = 1;
        -:  507:
        2:  508:    rlim = (float)max(nx, ny);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  509:
        2:  510:    first_rlim = rlim;		/*used in timing-driven placement for exponent computation */
        2:  511:    final_rlim = 1;
        2:  512:    inverse_delta_rlim = 1 / (first_rlim - final_rlim);
        -:  513:
        4:  514:    t = starting_t(&cost, &bb_cost, &timing_cost,
call    0 returned 100%
        2:  515:		   placer_opts.place_cost_type,
        -:  516:		   old_region_occ_x, old_region_occ_y,
        -:  517:		   placer_opts.num_regions, fixed_pins, annealing_sched,
        -:  518:		   move_lim, rlim, placer_opts.place_algorithm,
        -:  519:		   placer_opts.timing_tradeoff, inverse_prev_bb_cost,
        -:  520:		   inverse_prev_timing_cost, &delay_cost);
        2:  521:    tot_iter = 0;
        2:  522:    moves_since_cost_recompute = 0;
        2:  523:    printf
call    0 returned 100%
        -:  524:	("Initial Placement Cost: %g bb_cost: %g td_cost: %g delay_cost: %g\n\n",
        -:  525:	 cost, bb_cost, timing_cost, delay_cost);
        -:  526:
        -:  527:#ifndef SPEC
        2:  528:    printf
call    0 returned 100%
        -:  529:	("%11s  %10s %11s  %11s  %11s %11s  %11s %9s %8s  %7s  %7s  %10s  %7s\n",
        -:  530:	 "T", "Cost", "Av. BB Cost", "Av. TD Cost", "Av Tot Del",
        -:  531:	 "P to P Del", "d_max", "Ac Rate", "Std Dev", "R limit", "Exp",
        -:  532:	 "Tot. Moves", "Alpha");
        2:  533:    printf
call    0 returned 100%
        -:  534:	("%11s  %10s %11s  %11s  %11s %11s  %11s %9s %8s  %7s  %7s  %10s  %7s\n",
        -:  535:	 "--------", "----------", "-----------", "-----------",
        -:  536:	 "---------", "----------", "-----", "-------", "-------",
        -:  537:	 "-------", "-------", "----------", "-----");
        -:  538:#endif
        -:  539:
        2:  540:    sprintf(msg,
        -:  541:	    "Initial Placement.  Cost: %g  BB Cost: %g  TD Cost %g  Delay Cost: %g "
        -:  542:	    "\t d_max %g Channel Factor: %d", cost, bb_cost, timing_cost,
        -:  543:	    delay_cost, d_max, width_fac);
        2:  544:    update_screen(MAJOR, msg, PLACEMENT, FALSE);
call    0 returned 100%
        -:  545:
      246:  546:    while(exit_crit(t, cost, annealing_sched) == 0)
call    0 returned 100%
branch  1 taken 99%
branch  2 taken 1% (fallthrough)
        -:  547:	{
        -:  548:
      484:  549:	    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      242:  550:	       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -:  551:		{
      242:  552:		    cost = 1;
        -:  553:		}
        -:  554:
      242:  555:	    av_cost = 0.;
      242:  556:	    av_bb_cost = 0.;
      242:  557:	    av_delay_cost = 0.;
      242:  558:	    av_timing_cost = 0.;
      242:  559:	    sum_of_squares = 0.;
      242:  560:	    success_sum = 0;
        -:  561:
      484:  562:	    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      242:  563:	       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -:  564:		{
        -:  565:
      242:  566:		    if(outer_crit_iter_count >=
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
      242:  567:		       placer_opts.recompute_crit_iter
    #####:  568:		       || placer_opts.inner_loop_recompute_divider != 0)
branch  0 never executed
branch  1 never executed
        -:  569:			{
        -:  570:#ifdef VERBOSE
        -:  571:			    printf("Outer Loop Recompute Criticalities\n");
        -:  572:#endif
      242:  573:			    place_delay_value = delay_cost / num_connections;
        -:  574:
      242:  575:			    if(placer_opts.place_algorithm ==
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  576:			       NET_TIMING_DRIVEN_PLACE)
    #####:  577:				load_constant_net_delay(net_delay,
call    0 never executed
        -:  578:							place_delay_value);
        -:  579:			    /*note, for path_based, the net delay is not updated since it is current,
        -:  580:			     *because it accesses point_to_point_delay array */
        -:  581:
      242:  582:			    load_timing_graph_net_delays(net_delay);
call    0 returned 100%
      242:  583:			    d_max = load_net_slack(net_slack, 0);
call    0 returned 100%
      242:  584:			    load_criticalities(placer_opts, net_slack, d_max,
call    0 returned 100%
        -:  585:					       crit_exponent);
        -:  586:			    /*recompute costs from scratch, based on new criticalities */
      242:  587:			    comp_td_costs(&timing_cost, &delay_cost);
call    0 returned 100%
      242:  588:			    outer_crit_iter_count = 0;
        -:  589:			}
      242:  590:		    outer_crit_iter_count++;
        -:  591:
        -:  592:		    /*at each temperature change we update these values to be used     */
        -:  593:		    /*for normalizing the tradeoff between timing and wirelength (bb)  */
      242:  594:		    inverse_prev_bb_cost = 1 / bb_cost;
      242:  595:		    inverse_prev_timing_cost = 1 / timing_cost;
        -:  596:		}
        -:  597:
      242:  598:	    inner_crit_iter_count = 1;
        -:  599:
  1725702:  600:	    for(inner_iter = 0; inner_iter < move_lim; inner_iter++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  601:		{
  3450920:  602:		    if(try_swap(t, &cost, &bb_cost, &timing_cost,
call    0 returned 100%
branch  1 taken 45% (fallthrough)
branch  2 taken 55%
  1725460:  603:				rlim, placer_opts.place_cost_type,
        -:  604:				old_region_occ_x, old_region_occ_y,
        -:  605:				placer_opts.num_regions, fixed_pins,
        -:  606:				placer_opts.place_algorithm,
        -:  607:				placer_opts.timing_tradeoff,
        -:  608:				inverse_prev_bb_cost,
        -:  609:				inverse_prev_timing_cost, &delay_cost,
        -:  610:				x_lookup) == 1)
        -:  611:			{
   773018:  612:			    success_sum++;
   773018:  613:			    av_cost += cost;
   773018:  614:			    av_bb_cost += bb_cost;
   773018:  615:			    av_timing_cost += timing_cost;
   773018:  616:			    av_delay_cost += delay_cost;
   773018:  617:			    sum_of_squares += cost * cost;
        -:  618:			}
        -:  619:
  1725460:  620:		    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  1725460:  621:		       || placer_opts.place_algorithm ==
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  622:		       PATH_TIMING_DRIVEN_PLACE)
        -:  623:			{
        -:  624:
  1725460:  625:			    if(inner_crit_iter_count >= inner_recompute_limit
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  626:			       && inner_iter != move_lim - 1)
branch  0 never executed
branch  1 never executed
        -:  627:				{	/*on last iteration don't recompute */
        -:  628:
    #####:  629:				    inner_crit_iter_count = 0;
        -:  630:#ifdef VERBOSE
        -:  631:				    printf
        -:  632:					("Inner Loop Recompute Criticalities\n");
        -:  633:#endif
    #####:  634:				    if(placer_opts.place_algorithm ==
branch  0 never executed
branch  1 never executed
        -:  635:				       NET_TIMING_DRIVEN_PLACE)
        -:  636:					{
    #####:  637:					    place_delay_value =
    #####:  638:						delay_cost / num_connections;
    #####:  639:					    load_constant_net_delay(net_delay,
call    0 never executed
        -:  640:								    place_delay_value);
        -:  641:					}
        -:  642:
    #####:  643:				    load_timing_graph_net_delays(net_delay);
call    0 never executed
    #####:  644:				    d_max = load_net_slack(net_slack, 0);
call    0 never executed
    #####:  645:				    load_criticalities(placer_opts, net_slack,
call    0 never executed
        -:  646:						       d_max, crit_exponent);
    #####:  647:				    comp_td_costs(&timing_cost, &delay_cost);
call    0 never executed
        -:  648:				}
  1725460:  649:			    inner_crit_iter_count++;
        -:  650:			}
        -:  651:#ifdef VERBOSE
        -:  652:		    printf
        -:  653:			("t = %g  cost = %g   bb_cost = %g timing_cost = %g move = %d dmax = %g\n",
        -:  654:			 t, cost, bb_cost, timing_cost, inner_iter, d_max);
        -:  655:		    if(fabs
        -:  656:		       (bb_cost -
        -:  657:			comp_bb_cost(CHECK, placer_opts.place_cost_type,
        -:  658:				     placer_opts.num_regions)) >
        -:  659:		       bb_cost * ERROR_TOL)
        -:  660:			exit(1);
        -:  661:#endif
        -:  662:		}
        -:  663:
        -:  664:	    /* Lines below prevent too much round-off error from accumulating *
        -:  665:	     * in the cost over many iterations.  This round-off can lead to  *
        -:  666:	     * error checks failing because the cost is different from what   *
        -:  667:	     * you get when you recompute from scratch.                       */
        -:  668:
      242:  669:	    moves_since_cost_recompute += move_lim;
      242:  670:	    if(moves_since_cost_recompute > MAX_MOVES_BEFORE_RECOMPUTE)
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -:  671:		{
       30:  672:		    new_bb_cost =
call    0 returned 100%
       30:  673:			recompute_bb_cost(placer_opts.place_cost_type,
        -:  674:					  placer_opts.num_regions);
       30:  675:		    if(fabs(new_bb_cost - bb_cost) > bb_cost * ERROR_TOL)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  676:			{
    #####:  677:			    printf
call    0 never executed
        -:  678:				("Error in try_place:  new_bb_cost = %g, old bb_cost = %g.\n",
        -:  679:				 new_bb_cost, bb_cost);
    #####:  680:			    exit(1);
call    0 never executed
        -:  681:			}
       30:  682:		    bb_cost = new_bb_cost;
        -:  683:
       30:  684:		    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
       30:  685:		       || placer_opts.place_algorithm ==
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  686:		       PATH_TIMING_DRIVEN_PLACE)
        -:  687:			{
       30:  688:			    comp_td_costs(&new_timing_cost, &new_delay_cost);
call    0 returned 100%
       60:  689:			    if(fabs(new_timing_cost - timing_cost) >
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       30:  690:			       timing_cost * ERROR_TOL)
        -:  691:				{
    #####:  692:				    printf
call    0 never executed
        -:  693:					("Error in try_place:  new_timing_cost = %g, old timing_cost = %g.\n",
        -:  694:					 new_timing_cost, timing_cost);
    #####:  695:				    exit(1);
call    0 never executed
        -:  696:				}
       60:  697:			    if(fabs(new_delay_cost - delay_cost) >
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
       30:  698:			       delay_cost * ERROR_TOL)
        -:  699:				{
    #####:  700:				    printf
call    0 never executed
        -:  701:					("Error in try_place:  new_delay_cost = %g, old delay_cost = %g.\n",
        -:  702:					 new_delay_cost, delay_cost);
    #####:  703:				    exit(1);
call    0 never executed
        -:  704:				}
       30:  705:			    timing_cost = new_timing_cost;
        -:  706:			}
        -:  707:
       30:  708:		    if(placer_opts.place_algorithm == BOUNDING_BOX_PLACE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  709:			{
    #####:  710:			    cost = new_bb_cost;
        -:  711:			}
       30:  712:		    moves_since_cost_recompute = 0;
        -:  713:		}
        -:  714:
      242:  715:	    tot_iter += move_lim;
      242:  716:	    success_rat = ((float)success_sum) / move_lim;
      242:  717:	    if(success_sum == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  718:		{
    #####:  719:		    av_cost = cost;
    #####:  720:		    av_bb_cost = bb_cost;
    #####:  721:		    av_timing_cost = timing_cost;
    #####:  722:		    av_delay_cost = delay_cost;
        -:  723:		}
        -:  724:	    else
        -:  725:		{
      242:  726:		    av_cost /= success_sum;
      242:  727:		    av_bb_cost /= success_sum;
      242:  728:		    av_timing_cost /= success_sum;
      242:  729:		    av_delay_cost /= success_sum;
        -:  730:		}
      242:  731:	    std_dev = get_std_dev(success_sum, sum_of_squares, av_cost);
call    0 returned 100%
        -:  732:
        -:  733:#ifndef SPEC
      242:  734:	    printf
call    0 returned 100%
        -:  735:		("%11.5g  %10.6g %11.6g  %11.6g  %11.6g %11.6g %11.4g %9.4g %8.3g  %7.4g  %7.4g  %10d  ",
        -:  736:		 t, av_cost, av_bb_cost, av_timing_cost, av_delay_cost,
        -:  737:		 place_delay_value, d_max, success_rat, std_dev, rlim,
        -:  738:		 crit_exponent, tot_iter); list line
        -:  739:#endif
        -:  740:
      242:  741:	    oldt = t;		/* for finding and printing alpha. */
      242:  742:	    update_t(&t, std_dev, rlim, success_rat, annealing_sched);
call    0 returned 100%
        -:  743:
        -:  744:#ifndef SPEC
      242:  745:	    printf("%7.4g\n", t / oldt);
call    0 returned 100%
        -:  746:#endif
        -:  747:
      242:  748:	    sprintf(msg,
        -:  749:		    "Cost: %g  BB Cost %g  TD Cost %g  Temperature: %g  d_max: %g",
        -:  750:		    cost, bb_cost, timing_cost, t, d_max);
      242:  751:	    update_screen(MINOR, msg, PLACEMENT, FALSE);
call    0 returned 100%
      242:  752:	    update_rlim(&rlim, success_rat);
call    0 returned 100%
        -:  753:
      484:  754:	    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
      242:  755:	       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -:  756:		{
      242:  757:		    crit_exponent =
      242:  758:			(1 -
      242:  759:			 (rlim -
      484:  760:			  final_rlim) * inverse_delta_rlim) *
      484:  761:			(placer_opts.td_place_exp_last -
      242:  762:			 placer_opts.td_place_exp_first) +
      242:  763:			placer_opts.td_place_exp_first;
        -:  764:		}
        -:  765:#ifdef VERBOSE
        -:  766:	    dump_clbs();
        -:  767:#endif
        -:  768:	}
        -:  769:
        2:  770:    t = 0;			/* freeze out */
        2:  771:    av_cost = 0.;
        2:  772:    av_bb_cost = 0.;
        2:  773:    av_timing_cost = 0.;
        2:  774:    sum_of_squares = 0.;
        2:  775:    av_delay_cost = 0.;
        2:  776:    success_sum = 0;
        -:  777:
        4:  778:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        2:  779:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -:  780:	{
        -:  781:	    /*at each temperature change we update these values to be used     */
        -:  782:	    /*for normalizing the tradeoff between timing and wirelength (bb)  */
        2:  783:	    if(outer_crit_iter_count >= placer_opts.recompute_crit_iter ||
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
branch  2 never executed
branch  3 never executed
    #####:  784:	       placer_opts.inner_loop_recompute_divider != 0)
        -:  785:		{
        -:  786:
        -:  787:#ifdef VERBOSE
        -:  788:		    printf("Outer Loop Recompute Criticalities\n");
        -:  789:#endif
        2:  790:		    place_delay_value = delay_cost / num_connections;
        -:  791:
        2:  792:		    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  793:			load_constant_net_delay(net_delay, place_delay_value);
call    0 never executed
        -:  794:
        2:  795:		    load_timing_graph_net_delays(net_delay);
call    0 returned 100%
        2:  796:		    d_max = load_net_slack(net_slack, 0);
call    0 returned 100%
        2:  797:		    load_criticalities(placer_opts, net_slack, d_max,
call    0 returned 100%
        -:  798:				       crit_exponent);
        -:  799:		    /*recompute criticaliies */
        2:  800:		    comp_td_costs(&timing_cost, &delay_cost);
call    0 returned 100%
        2:  801:		    outer_crit_iter_count = 0;
        -:  802:		}
        2:  803:	    outer_crit_iter_count++;
        -:  804:
        2:  805:	    inverse_prev_bb_cost = 1 / (bb_cost);
        2:  806:	    inverse_prev_timing_cost = 1 / (timing_cost);
        -:  807:	}
        -:  808:
        2:  809:    inner_crit_iter_count = 1;
        -:  810:
    14262:  811:    for(inner_iter = 0; inner_iter < move_lim; inner_iter++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  812:	{
    28520:  813:	    if(try_swap(t, &cost, &bb_cost, &timing_cost,
call    0 returned 100%
branch  1 taken 4% (fallthrough)
branch  2 taken 96%
    14260:  814:			rlim, placer_opts.place_cost_type,
        -:  815:			old_region_occ_x, old_region_occ_y,
        -:  816:			placer_opts.num_regions, fixed_pins,
        -:  817:			placer_opts.place_algorithm,
        -:  818:			placer_opts.timing_tradeoff, inverse_prev_bb_cost,
        -:  819:			inverse_prev_timing_cost, &delay_cost, x_lookup) == 1)
        -:  820:		{
      636:  821:		    success_sum++;
      636:  822:		    av_cost += cost;
      636:  823:		    av_bb_cost += bb_cost;
      636:  824:		    av_delay_cost += delay_cost;
      636:  825:		    av_timing_cost += timing_cost;
      636:  826:		    sum_of_squares += cost * cost;
        -:  827:
      636:  828:		    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      636:  829:		       || placer_opts.place_algorithm ==
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -:  830:		       PATH_TIMING_DRIVEN_PLACE)
        -:  831:			{
        -:  832:
      636:  833:			    if(inner_crit_iter_count >= inner_recompute_limit
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  834:			       && inner_iter != move_lim - 1)
branch  0 never executed
branch  1 never executed
        -:  835:				{
        -:  836:
    #####:  837:				    inner_crit_iter_count = 0;
        -:  838:#ifdef VERBOSE
        -:  839:				    printf
        -:  840:					("Inner Loop Recompute Criticalities\n");
        -:  841:#endif
    #####:  842:				    if(placer_opts.place_algorithm ==
branch  0 never executed
branch  1 never executed
        -:  843:				       NET_TIMING_DRIVEN_PLACE)
        -:  844:					{
    #####:  845:					    place_delay_value =
    #####:  846:						delay_cost / num_connections;
    #####:  847:					    load_constant_net_delay(net_delay,
call    0 never executed
        -:  848:								    place_delay_value);
        -:  849:					}
        -:  850:
    #####:  851:				    load_timing_graph_net_delays(net_delay);
call    0 never executed
    #####:  852:				    d_max = load_net_slack(net_slack, 0);
call    0 never executed
    #####:  853:				    load_criticalities(placer_opts, net_slack,
call    0 never executed
        -:  854:						       d_max, crit_exponent);
    #####:  855:				    comp_td_costs(&timing_cost, &delay_cost);
call    0 never executed
        -:  856:				}
      636:  857:			    inner_crit_iter_count++;
        -:  858:			}
        -:  859:		}
        -:  860:#ifdef VERBOSE
        -:  861:	    printf("t = %g  cost = %g   move = %d\n", t, cost, tot_iter);
        -:  862:#endif
        -:  863:	}
        2:  864:    tot_iter += move_lim;
        2:  865:    success_rat = ((float)success_sum) / move_lim;
        2:  866:    if(success_sum == 0)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  867:	{
    #####:  868:	    av_cost = cost;
    #####:  869:	    av_bb_cost = bb_cost;
    #####:  870:	    av_delay_cost = delay_cost;
    #####:  871:	    av_timing_cost = timing_cost;
        -:  872:	}
        -:  873:    else
        -:  874:	{
        2:  875:	    av_cost /= success_sum;
        2:  876:	    av_bb_cost /= success_sum;
        2:  877:	    av_delay_cost /= success_sum;
        2:  878:	    av_timing_cost /= success_sum;
        -:  879:	}
        -:  880:
        2:  881:    std_dev = get_std_dev(success_sum, sum_of_squares, av_cost);
call    0 returned 100%
        -:  882:
        -:  883:
        -:  884:#ifndef SPEC
        2:  885:    printf
call    0 returned 100%
        -:  886:	("%11.5g  %10.6g %11.6g  %11.6g  %11.6g %11.6g %11.4g %9.4g %8.3g  %7.4g  %7.4g  %10d  \n\n",
        -:  887:	 t, av_cost, av_bb_cost, av_timing_cost, av_delay_cost,
        -:  888:	 place_delay_value, d_max, success_rat, std_dev, rlim,
        -:  889:	 crit_exponent, tot_iter);
        -:  890:
        -:  891:#endif
        -:  892:
        -:  893:#ifdef VERBOSE
        -:  894:    dump_clbs();
        -:  895:#endif
        -:  896:
        2:  897:    check_place(bb_cost, timing_cost, placer_opts.place_cost_type,
call    0 returned 100%
        -:  898:		placer_opts.num_regions, placer_opts.place_algorithm,
        -:  899:		delay_cost);
        -:  900:
        4:  901:    if(placer_opts.enable_timing_computations &&
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2:  902:       placer_opts.place_algorithm == BOUNDING_BOX_PLACE)
        -:  903:	{
        -:  904:	    /*need this done since the timing data has not been kept up to date*
        -:  905:	     *in bounding_box mode */
    #####:  906:	    for(inet = 0; inet < num_nets; inet++)
branch  0 never executed
branch  1 never executed
    #####:  907:		for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
branch  0 never executed
branch  1 never executed
    #####:  908:		    timing_place_crit[inet][ipin] = 0;	/*dummy crit values */
    #####:  909:	    comp_td_costs(&timing_cost, &delay_cost);	/*computes point_to_point_delay_cost */
call    0 never executed
        -:  910:	}
        -:  911:
        4:  912:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2:  913:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE ||
branch  0 never executed
branch  1 never executed
    #####:  914:       placer_opts.enable_timing_computations)
        -:  915:	{
        2:  916:	    net_delay = point_to_point_delay_cost;	/*this makes net_delay up to date with    *
        -:  917:							 *the same values that the placer is using*/
        2:  918:	    load_timing_graph_net_delays(net_delay);
call    0 returned 100%
        2:  919:	    est_crit = load_net_slack(net_slack, 0);
call    0 returned 100%
        -:  920:#ifdef CREATE_ECHO_FILES
        -:  921:/*		print_sink_delays("placement_sink_delays.echo"); */
        -:  922:	    print_net_slack("placement_net_slacks.echo", net_slack);
        -:  923:	    print_critical_path("placement_crit_path.echo",
        -:  924:				*subblock_data_ptr);
        -:  925:#endif /* CREATE_ECHO_FILES */
        2:  926:	    printf("Placement Estimated Crit Path Delay: %g\n\n", est_crit);
call    0 returned 100%
        -:  927:	}
        -:  928:
        -:  929:
        2:  930:    sprintf(msg,
        -:  931:	    "Placement. Cost: %g  bb_cost: %g td_cost: %g Channel Factor: %d d_max: %g",
        -:  932:	    cost, bb_cost, timing_cost, width_fac, d_max);
        2:  933:    printf
call    0 returned 100%
        -:  934:	("Placement. Cost: %g  bb_cost: %g  td_cost: %g  delay_cost: %g.\n",
        -:  935:	 cost, bb_cost, timing_cost, delay_cost);
        2:  936:    update_screen(MAJOR, msg, PLACEMENT, FALSE);
call    0 returned 100%
        -:  937:
        -:  938:#ifdef SPEC
        -:  939:    printf("Total moves attempted: %d.0\n", tot_iter);
        -:  940:#endif
        -:  941:
        4:  942:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2:  943:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE ||
branch  0 never executed
branch  1 never executed
    #####:  944:       placer_opts.enable_timing_computations)
        -:  945:	{
        -:  946:
        2:  947:	    net_delay = remember_net_delay_original_ptr;
        -:  948:
        2:  949:	    free_placement_structs(placer_opts.place_cost_type,
call    0 returned 100%
        -:  950:				   placer_opts.num_regions, old_region_occ_x,
        -:  951:				   old_region_occ_y, placer_opts);
        2:  952:	    free_lookups_and_criticalities(&net_delay, &net_slack);
call    0 returned 100%
        -:  953:	}
        -:  954:
        -:  955:    /* placement is done - find mst of all nets.
        -:  956:     * creating mst for each net; this gives me an ordering of sinks 
        -:  957:     * by which I will direct search (A*) for. */
        2:  958:    if(*mst)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:  959:	{
    #####:  960:	    for(inet = 0; inet < num_nets; inet++)
branch  0 never executed
branch  1 never executed
        -:  961:		{
    #####:  962:		    assert((*mst)[inet]);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####:  963:		    free((*mst)[inet]);
        -:  964:		}
    #####:  965:	    free(*mst);
        -:  966:	}
        2:  967:    *mst = (t_mst_edge **) my_malloc(sizeof(t_mst_edge *) * num_nets);
call    0 returned 100%
     1024:  968:    for(inet = 0; inet < num_nets; inet++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  969:	{
     1022:  970:	    (*mst)[inet] = get_mst_of_net(inet);
call    0 returned 100%
        -:  971:	}
        2:  972:    free(x_lookup);
        2:  973:}
        -:  974:
        -:  975:static int
function count_connections called 2 returned 100% blocks executed 100%
        2:  976:count_connections()
        -:  977:{
        -:  978:    /*only count non-global connections */
        -:  979:
        -:  980:    int count, inet;
        -:  981:
        2:  982:    count = 0;
        -:  983:
     1024:  984:    for(inet = 0; inet < num_nets; inet++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:  985:	{
        -:  986:
     1022:  987:	    if(net[inet].is_global)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2:  988:		continue;
        -:  989:
     1020:  990:	    count += net[inet].num_sinks;
        -:  991:	}
        2:  992:    return (count);
        -:  993:}
        -:  994:
        -:  995:static void
function compute_net_pin_index_values called 2 returned 100% blocks executed 100%
        2:  996:compute_net_pin_index_values()
        -:  997:{
        -:  998:    /*computes net_pin_index array, this array allows us to quickly */
        -:  999:    /*find what pin on the net a block pin corresponds to */
        -: 1000:
        -: 1001:    int inet, netpin, blk, iblk, ipin;
        -: 1002:    t_type_ptr type;
        -: 1003:
        -: 1004:    /*initialize values to OPEN */
      278: 1005:    for(iblk = 0; iblk < num_blocks; iblk++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 1006:	{
      276: 1007:	    type = block[iblk].type;
     6760: 1008:	    for(ipin = 0; ipin < type->num_pins; ipin++)
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -: 1009:		{
     6484: 1010:		    net_pin_index[iblk][ipin] = OPEN;
        -: 1011:		}
        -: 1012:	}
        -: 1013:
     1024: 1014:    for(inet = 0; inet < num_nets; inet++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 1015:	{
        -: 1016:
     1022: 1017:	    if(net[inet].is_global)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        2: 1018:		continue;
        -: 1019:
     4342: 1020:	    for(netpin = 0; netpin <= net[inet].num_sinks; netpin++)
branch  0 taken 77%
branch  1 taken 23% (fallthrough)
        -: 1021:		{
     3322: 1022:		    blk = net[inet].node_block[netpin];
     3322: 1023:		    net_pin_index[blk][net[inet].node_block_pin[netpin]] =
        -: 1024:			netpin;
        -: 1025:		}
        -: 1026:	}
        2: 1027:}
        -: 1028:
        -: 1029:
        -: 1030:static double
function get_std_dev called 246 returned 100% blocks executed 88%
      246: 1031:get_std_dev(int n,
        -: 1032:	    double sum_x_squared,
        -: 1033:	    double av_x)
        -: 1034:{
        -: 1035:
        -: 1036:    /* Returns the standard deviation of data set x.  There are n sample points, *
        -: 1037:     * sum_x_squared is the summation over n of x^2 and av_x is the average x.   *
        -: 1038:     * All operations are done in double precision, since round off error can be *
        -: 1039:     * a problem in the initial temp. std_dev calculation for big circuits.      */
        -: 1040:
        -: 1041:    double std_dev;
        -: 1042:
      246: 1043:    if(n <= 1)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1044:	std_dev = 0.;
        -: 1045:    else
      246: 1046:	std_dev = (sum_x_squared - n * av_x * av_x) / (double)(n - 1);
        -: 1047:
      246: 1048:    if(std_dev > 0.)		/* Very small variances sometimes round negative */
branch  0 taken 95% (fallthrough)
branch  1 taken 5%
      234: 1049:	std_dev = sqrt(std_dev);
        -: 1050:    else
       12: 1051:	std_dev = 0.;
        -: 1052:
      246: 1053:    return (std_dev);
        -: 1054:}
        -: 1055:
        -: 1056:
        -: 1057:static void
function update_rlim called 242 returned 100% blocks executed 100%
      242: 1058:update_rlim(float *rlim,
        -: 1059:	    float success_rat)
        -: 1060:{
        -: 1061:
        -: 1062:    /* Update the range limited to keep acceptance prob. near 0.44.  Use *
        -: 1063:     * a floating point rlim to allow gradual transitions at low temps.  */
        -: 1064:
        -: 1065:    float upper_lim;
        -: 1066:
      242: 1067:    *rlim = (*rlim) * (1. - 0.44 + success_rat);
      242: 1068:    upper_lim = max(nx, ny);
      242: 1069:    *rlim = min(*rlim, upper_lim);
branch  0 taken 32% (fallthrough)
branch  1 taken 68%
      242: 1070:    *rlim = max(*rlim, 1.);
branch  0 taken 71% (fallthrough)
branch  1 taken 29%
      242: 1071:}
        -: 1072:
        -: 1073:
        -: 1074:/* Update the temperature according to the annealing schedule selected. */
        -: 1075:static void
function update_t called 242 returned 100% blocks executed 91%
      242: 1076:update_t(float *t,
        -: 1077:	 float std_dev,
        -: 1078:	 float rlim,
        -: 1079:	 float success_rat,
        -: 1080:	 struct s_annealing_sched annealing_sched)
        -: 1081:{
        -: 1082:
        -: 1083:    /*  float fac; */
        -: 1084:
      242: 1085:    if(annealing_sched.type == USER_SCHED)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1086:	{
    #####: 1087:	    *t = annealing_sched.alpha_t * (*t);
        -: 1088:	}
        -: 1089:
        -: 1090:    /* Old standard deviation based stuff is below.  This bogs down horribly 
        -: 1091:     * for big circuits (alu4 and especially bigkey_mod). */
        -: 1092:    /* #define LAMBDA .7  */
        -: 1093:    /* ------------------------------------ */
        -: 1094:#if 0
        -: 1095:    else if(std_dev == 0.)
        -: 1096:	{
        -: 1097:	    *t = 0.;
        -: 1098:	}
        -: 1099:    else
        -: 1100:	{
        -: 1101:	    fac = exp(-LAMBDA * (*t) / std_dev);
        -: 1102:	    fac = max(0.5, fac);
        -: 1103:	    *t = (*t) * fac;
        -: 1104:	}
        -: 1105:#endif
        -: 1106:    /* ------------------------------------- */
        -: 1107:
        -: 1108:    else
        -: 1109:    {				/* AUTO_SCHED */
      242: 1110:	if(success_rat > 0.96)
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
        -: 1111:	    {
        8: 1112:		*t = (*t) * 0.5;
        -: 1113:	    }
      234: 1114:	else if(success_rat > 0.8)
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -: 1115:	    {
       18: 1116:		*t = (*t) * 0.9;
        -: 1117:	    }
      216: 1118:	else if(success_rat > 0.15 || rlim > 1.)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1119:	    {
      202: 1120:		*t = (*t) * 0.95;
        -: 1121:	    }
        -: 1122:	else
        -: 1123:	    {
       14: 1124:		*t = (*t) * 0.8;
        -: 1125:	    }
        -: 1126:    }
      242: 1127:}
        -: 1128:
        -: 1129:
        -: 1130:static int
function exit_crit called 244 returned 100% blocks executed 63%
      244: 1131:exit_crit(float t,
        -: 1132:	  float cost,
        -: 1133:	  struct s_annealing_sched annealing_sched)
        -: 1134:{
        -: 1135:
        -: 1136:    /* Return 1 when the exit criterion is met.                        */
        -: 1137:
      244: 1138:    if(annealing_sched.type == USER_SCHED)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1139:	{
    #####: 1140:	    if(t < annealing_sched.exit_t)
branch  0 never executed
branch  1 never executed
        -: 1141:		{
    #####: 1142:		    return (1);
        -: 1143:		}
        -: 1144:	    else
        -: 1145:		{
    #####: 1146:		    return (0);
        -: 1147:		}
        -: 1148:	}
        -: 1149:
        -: 1150:    /* Automatic annealing schedule */
        -: 1151:
      244: 1152:    if(t < 0.005 * cost / num_nets)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 1153:	{
        2: 1154:	    return (1);
        -: 1155:	}
        -: 1156:    else
        -: 1157:	{
      242: 1158:	    return (0);
        -: 1159:	}
        -: 1160:}
        -: 1161:
        -: 1162:
        -: 1163:static float
function starting_t called 2 returned 100% blocks executed 82%
        2: 1164:starting_t(float *cost_ptr,
        -: 1165:	   float *bb_cost_ptr,
        -: 1166:	   float *timing_cost_ptr,
        -: 1167:	   int place_cost_type,
        -: 1168:	   float **old_region_occ_x,
        -: 1169:	   float **old_region_occ_y,
        -: 1170:	   int num_regions,
        -: 1171:	   boolean fixed_pins,
        -: 1172:	   struct s_annealing_sched annealing_sched,
        -: 1173:	   int max_moves,
        -: 1174:	   float rlim,
        -: 1175:	   enum e_place_algorithm place_algorithm,
        -: 1176:	   float timing_tradeoff,
        -: 1177:	   float inverse_prev_bb_cost,
        -: 1178:	   float inverse_prev_timing_cost,
        -: 1179:	   float *delay_cost_ptr)
        -: 1180:{
        -: 1181:
        -: 1182:    /* Finds the starting temperature (hot condition).              */
        -: 1183:
        -: 1184:    int i, num_accepted, move_lim;
        -: 1185:    double std_dev, av, sum_of_squares;	/* Double important to avoid round off */
        -: 1186:    int *x_lookup;
        -: 1187:
        2: 1188:    x_lookup = (int *)my_malloc(nx * sizeof(int));
call    0 returned 100%
        -: 1189:
        2: 1190:    if(annealing_sched.type == USER_SCHED)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1191:	return (annealing_sched.init_t);
        -: 1192:
        2: 1193:    move_lim = min(max_moves, num_blocks);
        -: 1194:
        2: 1195:    num_accepted = 0;
        2: 1196:    av = 0.;
        2: 1197:    sum_of_squares = 0.;
        -: 1198:
        -: 1199:    /* Try one move per block.  Set t high so essentially all accepted. */
        -: 1200:
      278: 1201:    for(i = 0; i < move_lim; i++)
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 1202:	{
      276: 1203:	    if(try_swap(1.e30, cost_ptr, bb_cost_ptr, timing_cost_ptr, rlim,
call    0 returned 100%
branch  1 taken 100% (fallthrough)
branch  2 taken 0%
        -: 1204:			place_cost_type,
        -: 1205:			old_region_occ_x, old_region_occ_y, num_regions,
        -: 1206:			fixed_pins, place_algorithm, timing_tradeoff,
        -: 1207:			inverse_prev_bb_cost, inverse_prev_timing_cost,
        -: 1208:			delay_cost_ptr, x_lookup) == 1)
        -: 1209:		{
      276: 1210:		    num_accepted++;
      276: 1211:		    av += *cost_ptr;
      276: 1212:		    sum_of_squares += *cost_ptr * (*cost_ptr);
        -: 1213:		}
        -: 1214:	}
        -: 1215:
        2: 1216:    if(num_accepted != 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 1217:	av /= num_accepted;
        -: 1218:    else
    #####: 1219:	av = 0.;
        -: 1220:
        2: 1221:    std_dev = get_std_dev(num_accepted, sum_of_squares, av);
call    0 returned 100%
        -: 1222:
        -: 1223:#ifdef DEBUG
        2: 1224:    if(num_accepted != move_lim)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1225:	{
    #####: 1226:	    printf
call    0 never executed
        -: 1227:		("Warning:  Starting t: %d of %d configurations accepted.\n",
        -: 1228:		 num_accepted, move_lim);
        -: 1229:	}
        -: 1230:#endif
        -: 1231:
        -: 1232:#ifdef VERBOSE
        -: 1233:    printf("std_dev: %g, average cost: %g, starting temp: %g\n",
        -: 1234:	   std_dev, av, 20. * std_dev);
        -: 1235:#endif
        -: 1236:
        2: 1237:    free(x_lookup);
        -: 1238:
        -: 1239:    /* Set the initial temperature to 20 times the standard of deviation */
        -: 1240:    /* so that the initial temperature adjusts according to the circuit */
        2: 1241:    return (20. * std_dev);
        -: 1242:}
        -: 1243:
        -: 1244:
        -: 1245:static int
function try_swap called 1739996 returned 100% blocks executed 87%
  1739996: 1246:try_swap(float t,
        -: 1247:	 float *cost,
        -: 1248:	 float *bb_cost,
        -: 1249:	 float *timing_cost,
        -: 1250:	 float rlim,
        -: 1251:	 int place_cost_type,
        -: 1252:	 float **old_region_occ_x,
        -: 1253:	 float **old_region_occ_y,
        -: 1254:	 int num_regions,
        -: 1255:	 boolean fixed_pins,
        -: 1256:	 enum e_place_algorithm place_algorithm,
        -: 1257:	 float timing_tradeoff,
        -: 1258:	 float inverse_prev_bb_cost,
        -: 1259:	 float inverse_prev_timing_cost,
        -: 1260:	 float *delay_cost,
        -: 1261:	 int *x_lookup)
        -: 1262:{
        -: 1263:
        -: 1264:    /* Picks some block and moves it to another spot.  If this spot is   *
        -: 1265:     * occupied, switch the blocks.  Assess the change in cost function  *
        -: 1266:     * and accept or reject the move.  If rejected, return 0.  If        *
        -: 1267:     * accepted return 1.  Pass back the new value of the cost function. * 
        -: 1268:     * rlim is the range limiter.                                                                            */
        -: 1269:
        -: 1270:    int b_from, x_to, y_to, z_to, x_from, y_from, z_from, b_to;
        -: 1271:    int i, k, inet, keep_switch, num_of_pins, max_pins_per_fb;
        -: 1272:    int num_nets_affected, bb_index;
        -: 1273:    float delta_c, bb_delta_c, timing_delta_c, delay_delta_c, newcost;
        -: 1274:    static struct s_bb *bb_coord_new = NULL;
        -: 1275:    static struct s_bb *bb_edge_new = NULL;
        -: 1276:    static int *nets_to_update = NULL, *net_block_moved = NULL;
        -: 1277:
  1739996: 1278:    max_pins_per_fb = 0;
  8699980: 1279:    for(i = 0; i < num_types; i++)
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 1280:	{
  6959984: 1281:	    max_pins_per_fb =
  6959984: 1282:		max(max_pins_per_fb, type_descriptors[i].num_pins);
        -: 1283:	}
        -: 1284:
        -: 1285:    /* Allocate the local bb_coordinate storage, etc. only once. */
        -: 1286:
  1739996: 1287:    if(bb_coord_new == NULL)
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 1288:	{
        2: 1289:	    bb_coord_new = (struct s_bb *)my_malloc(2 * max_pins_per_fb * //opt
call    0 returned 100%
        -: 1290:						    sizeof(struct s_bb));
        2: 1291:	    bb_edge_new = (struct s_bb *)my_malloc(2 * max_pins_per_fb *
call    0 returned 100%
        -: 1292:						   sizeof(struct s_bb));
        2: 1293:	    nets_to_update =
        2: 1294:		(int *)my_malloc(2 * max_pins_per_fb * sizeof(int)); //opt
call    0 returned 100%
        2: 1295:	    net_block_moved =
        2: 1296:		(int *)my_malloc(2 * max_pins_per_fb * sizeof(int));
call    0 returned 100%
        -: 1297:	}
        -: 1298:
        -: 1299:
  1739996: 1300:    delay_delta_c = 0.0;
  1739996: 1301:    b_from = my_irand(num_blocks - 1); list line
call    0 returned 100%
        -: 1302:
        -: 1303:    /* If the pins are fixed we never move them from their initial    *
        -: 1304:     * random locations.  The code below could be made more efficient *
        -: 1305:     * by using the fact that pins appear first in the block list,    *
        -: 1306:     * but this shouldn't cause any significant slowdown and won't be *
        -: 1307:     * broken if I ever change the parser so that the pins aren't     *
        -: 1308:     * necessarily at the start of the block list.                    */
        -: 1309:
  1739996: 1310:    if(fixed_pins == TRUE)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1311:	{
    #####: 1312:	    while(block[b_from].type == IO_TYPE)
branch  0 never executed
branch  1 never executed
        -: 1313:		{
    #####: 1314:		    b_from = my_irand(num_blocks - 1);
call    0 never executed
        -: 1315:		}
        -: 1316:	}
        -: 1317:
  1739996: 1318:    x_from = block[b_from].x;
  1739996: 1319:    y_from = block[b_from].y;
  1739996: 1320:    z_from = block[b_from].z;
        -: 1321:
  1739996: 1322:    if(!find_to
call    0 returned 100%
branch  1 taken 3% (fallthrough)
branch  2 taken 97%
  1739996: 1323:       (x_from, y_from, block[b_from].type, rlim, x_lookup, &x_to, &y_to))
    43704: 1324:	return FALSE;
        -: 1325:
        -: 1326:    /* Make the switch in order to make computing the new bounding *
        -: 1327:     * box simpler.  If the cost increase is too high, switch them *
        -: 1328:     * back.  (block data structures switched, clbs not switched   *
        -: 1329:     * until success of move is determined.)                       */
        -: 1330:
  1696292: 1331:    
  1696292: 1332:    //opt grid[x_to][y_to] is used frequently but never aliasing
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
        -: 1333:    //no subroutine that might bring side effect in the function. 
   794786: 1334:    z_to = 0;
call    0 returned 100%
        -: 1335:    if(grid[x_to][y_to].type->capacity > 1)
  1696292: 1336:	{
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -: 1337:	    z_to = my_irand(grid[x_to][y_to].type->capacity - 1);
   355140: 1338:	}
   355140: 1339:    if(grid[x_to][y_to].blocks[z_to] == EMPTY)
   355140: 1340:	{			/* Moving to an empty location */
   355140: 1341:	    b_to = EMPTY;
        -: 1342:	    block[b_from].x = x_to;
        -: 1343:	    block[b_from].y = y_to;
        -: 1344:	    block[b_from].z = z_to;
  1341152: 1345:	}
  1341152: 1346:    else
  1341152: 1347:	{			/* Swapping two blocks */
  1341152: 1348:	    b_to = grid[x_to][y_to].blocks[z_to];
        -: 1349:	    block[b_to].x = x_from;
  1341152: 1350:	    block[b_to].y = y_from;
  1341152: 1351:	    block[b_to].z = z_from;
  1341152: 1352:
        -: 1353:	    block[b_from].x = x_to;
        -: 1354:	    block[b_from].y = y_to;
        -: 1355:	    block[b_from].z = z_to;
        -: 1356:	}
        -: 1357:
        -: 1358:    /* Now update the cost function.  May have to do major optimizations *
        -: 1359:     * here later.                                                       */
        -: 1360:
  1696292: 1361:    /* I'm using negative values of temp_net_cost as a flag, so DO NOT   *
  1696292: 1362:     * use cost functions that can go negative.                          */
  1696292: 1363:
        -: 1364:    delta_c = 0;		/* Change in cost due to this swap. */
  1696292: 1365:    bb_delta_c = 0;
        -: 1366:    timing_delta_c = 0;
  1696292: 1367:
call    0 returned 100%
        -: 1368:    num_of_pins = block[b_from].type->num_pins;
        -: 1369:
  1696292: 1370:    num_nets_affected = find_affected_nets(nets_to_update, net_block_moved,
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1371:					   b_from, b_to, num_of_pins);
    #####: 1372:
call    0 never executed
        -: 1373:    if(place_cost_type == NONLINEAR_CONG)
        -: 1374:	{
  1696292: 1375:	    save_region_occ(old_region_occ_x, old_region_occ_y, num_regions);
        -: 1376:	}
 35711468: 1377:
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -: 1378:    bb_index = 0;		/* Index of new bounding box. */
 34015176: 1379:
        -: 1380:    for(k = 0; k < num_nets_affected; k++)
        -: 1381:	{
        -: 1382:	    inet = nets_to_update[k];
        -: 1383:
 34015176: 1384:	    /* If we swapped two blocks connected to the same net, its bounding box *
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
  2741646: 1385:	     * doesn't change.                                                      */
        -: 1386:
 31273530: 1387:	    if(net_block_moved[k] == FROM_AND_TO)
branch  0 taken 81% (fallthrough)
branch  1 taken 19%
        -: 1388:		continue;
 25257436: 1389:
call    0 returned 100%
        -: 1390:	    if(net[inet].num_sinks < SMALL_NET)
        -: 1391:		{
        -: 1392:		    get_non_updateable_bb(inet, &bb_coord_new[bb_index]);
  6016094: 1393:		}
branch  0 taken 53% (fallthrough)
branch  1 taken 47%
  6347420: 1394:	    else
call    0 returned 100%
  3173710: 1395:		{
        -: 1396:		    if(net_block_moved[k] == FROM)
        -: 1397:			update_bb(inet, &bb_coord_new[bb_index],
  5684768: 1398:				  &bb_edge_new[bb_index], x_from, y_from,
call    0 returned 100%
  2842384: 1399:				  x_to, y_to);
        -: 1400:		    else
        -: 1401:			update_bb(inet, &bb_coord_new[bb_index],
        -: 1402:				  &bb_edge_new[bb_index], x_to, y_to, x_from,
 31273530: 1403:				  y_from);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1404:		}
 62547060: 1405:
 31273530: 1406:	    if(place_cost_type != NONLINEAR_CONG)
call    0 returned 100%
 31273530: 1407:		{
        -: 1408:		    temp_net_cost[inet] =
        -: 1409:			get_net_cost(inet, &bb_coord_new[bb_index]);
        -: 1410:		    bb_delta_c += temp_net_cost[inet] - net_cost[inet];
        -: 1411:		}
    #####: 1412:	    else
call    0 never executed
        -: 1413:		{
    #####: 1414:		    /* Rip up, then replace with new bb. */
call    0 never executed
        -: 1415:		    update_region_occ(inet, &bb_coords[inet], -1,
        -: 1416:				      num_regions);
        -: 1417:		    update_region_occ(inet, &bb_coord_new[bb_index], 1,
 31273530: 1418:				      num_regions);
        -: 1419:		}
        -: 1420:
  1696292: 1421:	    bb_index++;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1422:	}
    #####: 1423:
call    0 never executed
    #####: 1424:    if(place_cost_type == NONLINEAR_CONG)
        -: 1425:	{
        -: 1426:	    newcost = nonlinear_cong_cost(num_regions);
        -: 1427:	    bb_delta_c = newcost - *bb_cost;
  1696292: 1428:	}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1429:
        -: 1430:
        -: 1431:    if(place_algorithm == NET_TIMING_DRIVEN_PLACE ||
        -: 1432:       place_algorithm == PATH_TIMING_DRIVEN_PLACE)
        -: 1433:	{
        -: 1434:	    /*in this case we redefine delta_c as a combination of timing and bb.  *
  1696292: 1435:	     *additionally, we normalize all values, therefore delta_c is in       *
call    0 returned 100%
        -: 1436:	     *relation to 1*/
        -: 1437:
  1696292: 1438:	    comp_delta_td_cost(b_from, b_to, num_of_pins, &timing_delta_c,
  1696292: 1439:			       &delay_delta_c); //opt subroutine by taking a look inside
  1696292: 1440:
        -: 1441:	    delta_c =
        -: 1442:		(1 - timing_tradeoff) * bb_delta_c * inverse_prev_bb_cost +
        -: 1443:		timing_tradeoff * timing_delta_c * inverse_prev_timing_cost;
    #####: 1444:	}
        -: 1445:    else
        -: 1446:	{
        -: 1447:	    delta_c = bb_delta_c;
  1696292: 1448:	}
call    0 returned 100%
        -: 1449:
        -: 1450:
        -: 1451:    keep_switch = assess_swap(delta_c, t);
  1696292: 1452:
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
        -: 1453:    /* 1 -> move accepted, 0 -> rejected. */
   773930: 1454:
   773930: 1455:    if(keep_switch)
        -: 1456:	{
        -: 1457:	    *cost = *cost + delta_c;
   773930: 1458:	    *bb_cost = *bb_cost + bb_delta_c;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 1459:
        -: 1460:
        -: 1461:	    if(place_algorithm == NET_TIMING_DRIVEN_PLACE ||
        -: 1462:	       place_algorithm == PATH_TIMING_DRIVEN_PLACE)
   773930: 1463:		{
   773930: 1464:		    /*update the point_to_point_timing_cost and point_to_point_delay_cost 
        -: 1465:		     * values from the temporary values */
   773930: 1466:		    *timing_cost = *timing_cost + timing_delta_c;
call    0 returned 100%
        -: 1467:		    *delay_cost = *delay_cost + delay_delta_c;
        -: 1468:
        -: 1469:		    update_td_cost(b_from, b_to, num_of_pins);
        -: 1470:		}
   773930: 1471:
        -: 1472:	    /* update net cost functions and reset flags. */
  8413416: 1473:
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -: 1474:	    bb_index = 0;
  7639486: 1475:
        -: 1476:	    for(k = 0; k < num_nets_affected; k++)
        -: 1477:		{
        -: 1478:		    inet = nets_to_update[k];
        -: 1479:
  7639486: 1480:		    /* If we swapped two blocks connected to the same net, its bounding box *
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -: 1481:		     * doesn't change.                                                      */
   498850: 1482:
   498850: 1483:		    if(net_block_moved[k] == FROM_AND_TO) 
        -: 1484:			{
        -: 1485:			    temp_net_cost[inet] = -1;
  7140636: 1486:			    continue;
  7140636: 1487:			}
branch  0 taken 22% (fallthrough)
branch  1 taken 78%
  1561978: 1488:
        -: 1489:		    bb_coords[inet] = bb_coord_new[bb_index];
  7140636: 1490:		    if(net[inet].num_sinks >= SMALL_NET)
        -: 1491:			bb_num_on_edges[inet] = bb_edge_new[bb_index];
  7140636: 1492:
  7140636: 1493:		    bb_index++;
        -: 1494:
        -: 1495:		    net_cost[inet] = temp_net_cost[inet];
        -: 1496:		    temp_net_cost[inet] = -1;
        -: 1497:		}
   773930: 1498:
   773930: 1499:	    /* Update fb data structures since we kept the move. */
        -: 1500:	    /* Swap physical location */
   773930: 1501:	    grid[x_to][y_to].blocks[z_to] = b_from;
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
        -: 1502:	    grid[x_from][y_from].blocks[z_from] = b_to; //opt grid[from]???
   261538: 1503:
   261538: 1504:	    if(EMPTY == b_to)
        -: 1505:		{		/* Moved to an empty location */
        -: 1506:		    grid[x_to][y_to].usage++;
        -: 1507:		    grid[x_from][y_from].usage--;
        -: 1508:		}
        -: 1509:	}
        -: 1510:
        -: 1511:    else
 27298052: 1512:	{			/* Move was rejected.  */
branch  0 taken 97%
branch  1 taken 3% (fallthrough)
        -: 1513:
 26375690: 1514:	    /* Reset the net cost function flags first. */
 26375690: 1515:	    for(k = 0; k < num_nets_affected; k++)
        -: 1516:		{
        -: 1517:		    inet = nets_to_update[k];
        -: 1518:		    temp_net_cost[inet] = -1;
   922362: 1519:		}
   922362: 1520:
   922362: 1521:	    /* Restore the block data structures to their state before the move. */
   922362: 1522:	    block[b_from].x = x_from; //opt block ?
branch  0 taken 90% (fallthrough)
branch  1 taken 10%
        -: 1523:	    block[b_from].y = y_from;
   828760: 1524:	    block[b_from].z = z_from;
   828760: 1525:	    if(b_to != EMPTY)
   828760: 1526:		{
        -: 1527:		    block[b_to].x = x_to;
        -: 1528:		    block[b_to].y = y_to;
        -: 1529:		    block[b_to].z = z_to;
   922362: 1530:		}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1531: list line
    #####: 1532:	    /* Restore the region occupancies to their state before the move. */
call    0 never executed
        -: 1533:	    if(place_cost_type == NONLINEAR_CONG)
        -: 1534:		{
        -: 1535:		    restore_region_occ(old_region_occ_x, old_region_occ_y,
        -: 1536:				       num_regions);
  1696292: 1537:		}
        -: 1538:	}
        -: 1539:
        -: 1540:    return (keep_switch);
        -: 1541:}
function save_region_occ called 0 returned 0% blocks executed 0%
    #####: 1542:
        -: 1543:
        -: 1544:static void
        -: 1545:save_region_occ(float **old_region_occ_x,
        -: 1546:		float **old_region_occ_y,
        -: 1547:		int num_regions)
        -: 1548:{
        -: 1549:
        -: 1550:    /* Saves the old occupancies of the placement subregions in case the  *
        -: 1551:     * current move is not accepted.  Used only for NONLINEAR_CONG.       */
    #####: 1552:
branch  0 never executed
branch  1 never executed
        -: 1553:    int i, j;
    #####: 1554:
branch  0 never executed
branch  1 never executed
        -: 1555:    for(i = 0; i < num_regions; i++)
    #####: 1556:	{
    #####: 1557:	    for(j = 0; j < num_regions; j++)
        -: 1558:		{
        -: 1559:		    old_region_occ_x[i][j] = place_region_x[i][j].occupancy;
    #####: 1560:		    old_region_occ_y[i][j] = place_region_y[i][j].occupancy;
        -: 1561:		}
        -: 1562:	}
        -: 1563:}
function restore_region_occ called 0 returned 0% blocks executed 0%
    #####: 1564:
        -: 1565:
        -: 1566:static void
        -: 1567:restore_region_occ(float **old_region_occ_x,
        -: 1568:		   float **old_region_occ_y,
        -: 1569:		   int num_regions)
        -: 1570:{
        -: 1571:
        -: 1572:    /* Restores the old occupancies of the placement subregions when the  *
        -: 1573:     * current move is not accepted.  Used only for NONLINEAR_CONG.       */
    #####: 1574:
branch  0 never executed
branch  1 never executed
        -: 1575:    int i, j;
    #####: 1576:
branch  0 never executed
branch  1 never executed
        -: 1577:    for(i = 0; i < num_regions; i++)
    #####: 1578:	{
    #####: 1579:	    for(j = 0; j < num_regions; j++)
        -: 1580:		{
        -: 1581:		    place_region_x[i][j].occupancy = old_region_occ_x[i][j];
    #####: 1582:		    place_region_y[i][j].occupancy = old_region_occ_y[i][j];
        -: 1583:		}
        -: 1584:	}
        -: 1585:}
function find_affected_nets called 1696292 returned 100% blocks executed 94%
  1696292: 1586:
        -: 1587:
        -: 1588:static int
        -: 1589:find_affected_nets(int *nets_to_update,
        -: 1590:		   int *net_block_moved,
        -: 1591:		   int b_from,
        -: 1592:		   int b_to,
        -: 1593:		   int num_of_pins)
        -: 1594:{
        -: 1595:
        -: 1596:    /* Puts a list of all the nets connected to b_from and b_to into          *
        -: 1597:     * nets_to_update.  Returns the number of affected nets.  Net_block_moved *
        -: 1598:     * is either FROM, TO or FROM_AND_TO -- the block connected to this net   *
        -: 1599:     * that has moved.                                                        */
  1696292: 1600:
        -: 1601:    int k, inet, affected_index, count;
 40117784: 1602:
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -: 1603:    affected_index = 0;
 38421492: 1604:
        -: 1605:    for(k = 0; k < num_of_pins; k++)
 38421492: 1606:	{
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
 18137800: 1607:	    inet = block[b_from].nets[k];
        -: 1608:
 20283692: 1609:	    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   780356: 1610:		continue;
        -: 1611:
        -: 1612:	    if(net[inet].is_global)
        -: 1613:		continue;
 19503336: 1614:
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   735744: 1615:	    /* This is here in case the same block connects to a net twice. */
        -: 1616:
 18767592: 1617:	    if(temp_net_cost[inet] > 0.)
 18767592: 1618:		continue;
 18767592: 1619:
 18767592: 1620:	    nets_to_update[affected_index] = inet;
        -: 1621:	    net_block_moved[affected_index] = FROM;
        -: 1622:	    affected_index++;
  1696292: 1623:	    temp_net_cost[inet] = 1.;	/* Flag to say we've marked this net. */
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -: 1624:	}
 35351024: 1625:
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -: 1626:    if(b_to != EMPTY)
 34009872: 1627:	{
        -: 1628:	    for(k = 0; k < num_of_pins; k++)
 34009872: 1629:		{
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
 14883704: 1630:		    inet = block[b_to].nets[k];
        -: 1631:
 19126168: 1632:		    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   763544: 1633:			continue;
        -: 1634:
 18362624: 1635:		    if(net[inet].is_global)
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -: 1636:			continue;
 25897604: 1637:
branch  0 taken 100%
branch  1 taken 0% (fallthrough)
        -: 1638:		    if(temp_net_cost[inet] > 0.)
 25897604: 1639:			{	/* Net already marked. */
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -: 1640:			    for(count = 0; count < affected_index; count++)
  3115040: 1641:				{
branch  0 taken 88% (fallthrough)
branch  1 taken 12%
  2741646: 1642:				    if(nets_to_update[count] == inet)
        -: 1643:					{
  3115040: 1644:					    if(net_block_moved[count] == FROM)
        -: 1645:						net_block_moved[count] =
        -: 1646:						    FROM_AND_TO;
        -: 1647:					    break;
        -: 1648:					}
  3115040: 1649:				}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1650:
    #####: 1651:#ifdef DEBUG
call    0 never executed
        -: 1652:			    if(count > affected_index)
        -: 1653:				{
        -: 1654:				    printf
    #####: 1655:					("Error in find_affected_nets -- count = %d,"
call    0 never executed
        -: 1656:					 " affected index = %d.\n", count,
        -: 1657:					 affected_index);
        -: 1658:				    exit(1);
        -: 1659:				}
        -: 1660:#endif
        -: 1661:			}
        -: 1662:
 15247584: 1663:		    else
 15247584: 1664:			{	/* Net not marked yet. */
 15247584: 1665:
 15247584: 1666:			    nets_to_update[affected_index] = inet;
        -: 1667:			    net_block_moved[affected_index] = TO;
        -: 1668:			    affected_index++;
        -: 1669:			    temp_net_cost[inet] = 1.;	/* Flag means we've  marked net. */
        -: 1670:			}
  1696292: 1671:		}
        -: 1672:	}
        -: 1673:
        -: 1674:    return (affected_index);
        -: 1675:}
function find_to called 1739996 returned 100% blocks executed 89%
  1739996: 1676:
        -: 1677:
        -: 1678:static boolean
        -: 1679:find_to(int x_from,
        -: 1680:	int y_from,
        -: 1681:	t_type_ptr type,
        -: 1682:	float rlim,
        -: 1683:	int *x_lookup,
        -: 1684:	int *x_to,
        -: 1685:	int *y_to)
        -: 1686:{
        -: 1687:
        -: 1688:    /* Returns the point to which I want to swap, properly range limited. 
        -: 1689:     * rlim must always be between 1 and nx (inclusive) for this routine  
        -: 1690:     * to work.  Assumes that a column only contains blocks of the same type.
        -: 1691:     */
        -: 1692:
  1739996: 1693:    int x_rel, y_rel, iside, iplace, rlx, rly, min_x, max_x, min_y, max_y;
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
  1739996: 1694:    int num_col_same_type, i, j;
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -: 1695:
  1739996: 1696:    rlx = min(nx, rlim);	/* Only needed when nx < ny. */
  1739996: 1697:    rly = min(ny, rlim);	/* Added rly for aspect_ratio != 1 case. */
  1739996: 1698:
  1739996: 1699:    min_x = max(1, x_from - rlx);
        -: 1700:    max_x = min(nx, x_from + rlx);
  1739996: 1701:    min_y = max(1, y_from - rly);
  1739996: 1702:    max_y = min(ny, y_from + rly);
  1739996: 1703:
branch  0 taken 54% (fallthrough)
branch  1 taken 46%
        -: 1704:    num_col_same_type = 0;
  7125138: 1705:    j = 0;
branch  0 taken 87%
branch  1 taken 13% (fallthrough)
        -: 1706:    if(type != IO_TYPE)
  6179928: 1707:	{
branch  0 taken 67% (fallthrough)
branch  1 taken 33%
        -: 1708:	    for(i = min_x; i <= max_x; i++)
  4126928: 1709:		{
  4126928: 1710:		    if(grid[i][1].type == type)
  4126928: 1711:			{
        -: 1712:			    num_col_same_type++;
        -: 1713:			    x_lookup[j] = i;
   945210: 1714:			    j++;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  1066728: 1715:			}
branch  0 taken 13% (fallthrough)
branch  1 taken 87%
branch  2 taken 64% (fallthrough)
branch  3 taken 36%
   121518: 1716:		}
    77814: 1717:	    assert(num_col_same_type != 0);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    43704: 1718:	    if(num_col_same_type == 1 &&
        -: 1719:	       ((((max_y - min_y) / type->height) - 1) <= 0
        -: 1720:		|| type->height > (ny / 2)))
        -: 1721:		return FALSE;
  1696292: 1722:	}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 1723:
    #####: 1724:#ifdef DEBUG
call    0 never executed
    #####: 1725:    if(rlx < 1 || rlx > nx)
call    0 never executed
        -: 1726:	{
        -: 1727:	    printf("Error in find_to: rlx = %d\n", rlx);
        -: 1728:	    exit(1);
        -: 1729:	}
        -: 1730:#endif
  2062474: 1731:
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 1732:    do
   982722: 1733:	{			/* Until (x_to, y_to) different from (x_from, y_from) */
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -: 1734:	    if(type == IO_TYPE)
   267068: 1735:		{		/* io_block to be moved. */
call    0 returned 100%
        -: 1736:		    if(rlx >= nx)
        -: 1737:			{
        -: 1738:			    iside = my_irand(3);
        -: 1739:			    /*                              *
        -: 1740:			     *       +-----1----+           *
        -: 1741:			     *       |          |           *
        -: 1742:			     *       |          |           *
        -: 1743:			     *       0          2           *
        -: 1744:			     *       |          |           *
   267068: 1745:			     *       |          |           *
branch  0 taken 25%
branch  1 taken 25%
branch  2 taken 25%
branch  3 taken 25%
branch  4 taken 0%
        -: 1746:			     *       +-----3----+           *
        -: 1747:			     *                              */
    66926: 1748:			    switch (iside)
call    0 returned 100%
    66926: 1749:				{
    66926: 1750:				case 0:
    66926: 1751:				    iplace = my_irand(ny - 1) + 1;
        -: 1752:				    *x_to = 0;
    67228: 1753:				    *y_to = iplace;
call    0 returned 100%
    67228: 1754:				    break;
    67228: 1755:				case 1:
    67228: 1756:				    iplace = my_irand(nx - 1) + 1;
        -: 1757:				    *x_to = iplace;
    66254: 1758:				    *y_to = ny + 1;
call    0 returned 100%
    66254: 1759:				    break;
    66254: 1760:				case 2:
    66254: 1761:				    iplace = my_irand(ny - 1) + 1;
        -: 1762:				    *x_to = nx + 1;
    66660: 1763:				    *y_to = iplace;
call    0 returned 100%
    66660: 1764:				    break;
    66660: 1765:				case 3:
    66660: 1766:				    iplace = my_irand(nx - 1) + 1;
        -: 1767:				    *x_to = iplace;
    #####: 1768:				    *y_to = 0;
call    0 never executed
        -: 1769:				    break;
    #####: 1770:				default:
call    0 never executed
        -: 1771:				    printf
        -: 1772:					("Error in find_to.  Unexpected io swap location.\n");
        -: 1773:				    exit(1);
        -: 1774:				}
   715654: 1775:			}
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 1776:		    else
   239174: 1777:			{	/* rlx is less than whole chip */
call    0 returned 100%
   239174: 1778:			    if(x_from == 0)
   239174: 1779:				{
   239174: 1780:				    iplace = my_irand(2 * rly);
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -: 1781:				    *y_to = y_from - rly + iplace;
    16286: 1782:				    *x_to = x_from;
    16286: 1783:				    if(*y_to > ny)
call    0 returned 100%
        -: 1784:					{
   222888: 1785:					    *y_to = ny + 1;
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
        -: 1786:					    *x_to = my_irand(rlx - 1) + 1;
    15100: 1787:					}
    15100: 1788:				    else if(*y_to < 1)
call    0 returned 100%
        -: 1789:					{
        -: 1790:					    *y_to = 0;
   476480: 1791:					    *x_to = my_irand(rlx - 1) + 1;
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        -: 1792:					}
   107590: 1793:				}
call    0 returned 100%
   107590: 1794:			    else if(x_from == nx + 1)
   107590: 1795:				{
   107590: 1796:				    iplace = my_irand(2 * rly);
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -: 1797:				    *y_to = y_from - rly + iplace;
    10362: 1798:				    *x_to = x_from;
    10362: 1799:				    if(*y_to > ny)
call    0 returned 100%
        -: 1800:					{
    97228: 1801:					    *y_to = ny + 1;
branch  0 taken 9% (fallthrough)
branch  1 taken 91%
        -: 1802:					    *x_to = nx - my_irand(rlx - 1);
     8744: 1803:					}
     8744: 1804:				    else if(*y_to < 1)
call    0 returned 100%
        -: 1805:					{
        -: 1806:					    *y_to = 0;
   368890: 1807:					    *x_to = nx - my_irand(rlx - 1);
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
        -: 1808:					}
   150478: 1809:				}
call    0 returned 100%
   150478: 1810:			    else if(y_from == 0)
   150478: 1811:				{
   150478: 1812:				    iplace = my_irand(2 * rlx);
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -: 1813:				    *x_to = x_from - rlx + iplace;
     8740: 1814:				    *y_to = y_from;
     8740: 1815:				    if(*x_to > nx)
call    0 returned 100%
        -: 1816:					{
   141738: 1817:					    *x_to = nx + 1;
branch  0 taken 10% (fallthrough)
branch  1 taken 90%
        -: 1818:					    *y_to = my_irand(rly - 1) + 1;
    14504: 1819:					}
    14504: 1820:				    else if(*x_to < 1)
call    0 returned 100%
        -: 1821:					{
        -: 1822:					    *x_to = 0;
        -: 1823:					    *y_to = my_irand(rly - 1) + 1;
        -: 1824:					}
   218412: 1825:				}
call    0 returned 100%
   218412: 1826:			    else
   218412: 1827:				{	/* *y_from == ny + 1 */
   218412: 1828:				    iplace = my_irand(2 * rlx);
branch  0 taken 5% (fallthrough)
branch  1 taken 95%
        -: 1829:				    *x_to = x_from - rlx + iplace;
    10814: 1830:				    *y_to = y_from;
    10814: 1831:				    if(*x_to > nx)
call    0 returned 100%
        -: 1832:					{
   207598: 1833:					    *x_to = nx + 1;
branch  0 taken 8% (fallthrough)
branch  1 taken 92%
        -: 1834:					    *y_to = ny - my_irand(rly - 1);
    16466: 1835:					}
    16466: 1836:				    else if(*x_to < 1)
call    0 returned 100%
        -: 1837:					{
        -: 1838:					    *x_to = 0;
        -: 1839:					    *y_to = ny - my_irand(rly - 1);
        -: 1840:					}
        -: 1841:				}
        -: 1842:			}	/* End rlx if */
  1079752: 1843:		}		/* end type if */
call    0 returned 100%
  1079752: 1844:	    else
call    0 returned 100%
  1079752: 1845:		{
        -: 1846:		    x_rel = my_irand(num_col_same_type - 1);
  1079752: 1847:		    y_rel =
  1079752: 1848:			my_irand(max
  1079752: 1849:				 (0, ((max_y - min_y) / type->height) - 1));
  1079752: 1850:		    *x_to = x_lookup[x_rel];
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
  1079752: 1851:		    *y_to = min_y + y_rel * type->height;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
call    4 never executed
        -: 1852:		    *y_to = (*y_to) - grid[*x_to][*y_to].offset;	/* align it */
        -: 1853:		    assert(*x_to >= 1 && *x_to <= nx);
  2062474: 1854:		    assert(*y_to >= 1 && *y_to <= ny);
branch  0 taken 41% (fallthrough)
branch  1 taken 59%
branch  2 taken 43%
branch  3 taken 57% (fallthrough)
        -: 1855:		}
        -: 1856:	}
  1696292: 1857:    while((x_from == *x_to) && (y_from == *y_to));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 100% (fallthrough)
branch  5 taken 0%
branch  6 taken 0% (fallthrough)
branch  7 taken 100%
        -: 1858:
    #####: 1859:#ifdef DEBUG
call    0 never executed
        -: 1860:    if(*x_to < 0 || *x_to > nx + 1 || *y_to < 0 || *y_to > ny + 1)
    #####: 1861:	{
call    0 never executed
        -: 1862:	    printf("Error in routine find_to:  (x_to,y_to) = (%d,%d)\n",
        -: 1863:		   *x_to, *y_to);
  1696292: 1864:	    exit(1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
  1696292: 1865:	}
        -: 1866:#endif
        -: 1867:    assert(type == grid[*x_to][*y_to].type);
        -: 1868:    return TRUE;
        -: 1869:}
function assess_swap called 1696292 returned 100% blocks executed 100%
  1696292: 1870:
        -: 1871:
        -: 1872:static int
        -: 1873:assess_swap(float delta_c,
        -: 1874:	    float t)
        -: 1875:{
        -: 1876:
        -: 1877:    /* Returns: 1 -> move accepted, 0 -> rejected. */
        -: 1878:
  1696292: 1879:    int accept;
branch  0 taken 24% (fallthrough)
branch  1 taken 76%
        -: 1880:    float prob_fac, fnum;
        -: 1881:
        -: 1882:    if(delta_c <= 0)
        -: 1883:	{
        -: 1884:
        -: 1885:#ifdef SPEC			/* Reduce variation in final solution due to round off */
   407074: 1886:	    fnum = my_frand();
   407074: 1887:#endif
        -: 1888:
        -: 1889:	    accept = 1;
  1289218: 1890:	    return (accept);
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
    12722: 1891:	}
        -: 1892:
  1276496: 1893:    if(t == 0.)
call    0 returned 100%
  1276496: 1894:	return (0);
  1276496: 1895:
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        -: 1896:    fnum = my_frand();
   366856: 1897:    prob_fac = exp(-delta_c / t);
        -: 1898:    if(prob_fac > fnum)
        -: 1899:	{
        -: 1900:	    accept = 1;
   909640: 1901:	}
        -: 1902:    else
  1276496: 1903:	{
        -: 1904:	    accept = 0;
        -: 1905:	}
        -: 1906:    return (accept);
        -: 1907:}
function recompute_bb_cost called 30 returned 100% blocks executed 56%
       30: 1908:
        -: 1909:
        -: 1910:static float
        -: 1911:recompute_bb_cost(int place_cost_type,
        -: 1912:		  int num_regions)
        -: 1913:{
        -: 1914:
        -: 1915:    /* Recomputes the cost to eliminate roundoff that may have accrued.  *
        -: 1916:     * This routine does as little work as possible to compute this new  *
        -: 1917:     * cost.                                                             */
        -: 1918:
       30: 1919:    int i, j, inet;
        -: 1920:    float cost;
        -: 1921:
        -: 1922:    cost = 0;
       30: 1923:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1924:    /* Initialize occupancies to zero if regions are being used. */
    #####: 1925:
branch  0 never executed
branch  1 never executed
        -: 1926:    if(place_cost_type == NONLINEAR_CONG)
    #####: 1927:	{
branch  0 never executed
branch  1 never executed
        -: 1928:	    for(i = 0; i < num_regions; i++)
    #####: 1929:		{
    #####: 1930:		    for(j = 0; j < num_regions; j++)
        -: 1931:			{
        -: 1932:			    place_region_x[i][j].occupancy = 0.;
        -: 1933:			    place_region_y[i][j].occupancy = 0.;
        -: 1934:			}
    15360: 1935:		}
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 1936:	}
        -: 1937:
    15330: 1938:    for(inet = 0; inet < num_nets; inet++)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 1939:	{			/* for each net ... */
        -: 1940:
        -: 1941:	    if(net[inet].is_global == FALSE)
        -: 1942:		{		/* Do only if not global. */
    15300: 1943:
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 1944:		    /* Bounding boxes don't have to be recomputed; they're correct. */
    15300: 1945:
        -: 1946:		    if(place_cost_type != NONLINEAR_CONG)
        -: 1947:			{
        -: 1948:			    cost += net_cost[inet];
    #####: 1949:			}
call    0 never executed
        -: 1950:		    else
        -: 1951:			{	/* Must be nonlinear_cong case. */
        -: 1952:			    update_region_occ(inet, &bb_coords[inet], 1,
        -: 1953:					      num_regions);
        -: 1954:			}
       30: 1955:		}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 1956:	}
    #####: 1957:
call    0 never executed
        -: 1958:    if(place_cost_type == NONLINEAR_CONG)
        -: 1959:	{
       30: 1960:	    cost = nonlinear_cong_cost(num_regions);
        -: 1961:	}
        -: 1962:
        -: 1963:    return (cost);
        -: 1964:}
function comp_td_point_to_point_delay called 51169916 returned 100% blocks executed 65%
 51169916: 1965:
        -: 1966:
        -: 1967:static float
        -: 1968:comp_td_point_to_point_delay(int inet,
        -: 1969:			     int ipin)
        -: 1970:{
        -: 1971:
        -: 1972:    /*returns the delay of one point to point connection */
        -: 1973:
        -: 1974:    int source_block, sink_block;
        -: 1975:    int delta_x, delta_y;
 51169916: 1976:    t_type_ptr source_type, sink_type;
        -: 1977:    float delay_source_to_sink;
 51169916: 1978:
 51169916: 1979:    delay_source_to_sink = 0.;
        -: 1980:
 51169916: 1981:    source_block = net[inet].node_block[0];
 51169916: 1982:    source_type = block[source_block].type;
        -: 1983:
 51169916: 1984:    sink_block = net[inet].node_block[ipin];
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
 51169916: 1985:    sink_type = block[sink_block].type;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        -: 1986:
 51169916: 1987:    assert(source_type != NULL);
 51169916: 1988:    assert(sink_type != NULL);
        -: 1989:
        -: 1990:    delta_x = abs(block[sink_block].x - block[source_block].x);
        -: 1991:    delta_y = abs(block[sink_block].y - block[source_block].y);
        -: 1992:
        -: 1993:    /* TODO low priority: Could be merged into one look-up table */
 51169916: 1994:    /* Note: This heuristic is terrible on Quality of Results.  
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        -: 1995:     * A much better heuristic is to create a more comprehensive lookup table but
  9185740: 1996:     * it's too late in the release cycle to do this.  Pushing until the next release */
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####: 1997:    if(source_type == IO_TYPE)
        -: 1998:	{
  9185740: 1999:	    if(sink_type == IO_TYPE)
        -: 2000:		delay_source_to_sink = delta_io_to_io[delta_x][delta_y];
        -: 2001:	    else
        -: 2002:		delay_source_to_sink = delta_io_to_fb[delta_x][delta_y];
 41984176: 2003:	}
branch  0 taken 3% (fallthrough)
branch  1 taken 97%
  1235324: 2004:    else
        -: 2005:	{
 40748852: 2006:	    if(sink_type == IO_TYPE)
        -: 2007:		delay_source_to_sink = delta_fb_to_io[delta_x][delta_y];
 51169916: 2008:	    else
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2009:		delay_source_to_sink = delta_fb_to_fb[delta_x][delta_y];
    #####: 2010:	}
call    0 never executed
        -: 2011:    if(delay_source_to_sink < 0)
    #####: 2012:	{
call    0 never executed
        -: 2013:	    printf
        -: 2014:		("Error in comp_td_point_to_point_delay in place.c, bad delay_source_to_sink value\n");
 51169916: 2015:	    exit(1);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2016:	}
    #####: 2017:
call    0 never executed
        -: 2018:    if(delay_source_to_sink < 0.)
    #####: 2019:	{
call    0 never executed
        -: 2020:	    printf
        -: 2021:		("Error in comp_td_point_to_point_delay in place.c, delay is less than 0\n");
 51169916: 2022:	    exit(1);
        -: 2023:	}
        -: 2024:
        -: 2025:    return (delay_source_to_sink);
        -: 2026:}
        -: 2027:
function update_td_cost called 773930 returned 100% blocks executed 100%
   773930: 2028:
        -: 2029:
        -: 2030:static void
        -: 2031:update_td_cost(int b_from,
        -: 2032:	       int b_to,
        -: 2033:	       int num_of_pins)
        -: 2034:{
        -: 2035:    /*update the point_to_point_timing_cost values from the temporary */
        -: 2036:    /*values for all connections that have changed */
 12572324: 2037:
branch  0 taken 94%
branch  1 taken 6% (fallthrough)
        -: 2038:    int blkpin, net_pin, inet, ipin;
        -: 2039:
 11798394: 2040:    for(blkpin = 0; blkpin < num_of_pins; blkpin++)
        -: 2041:	{
 11798394: 2042:
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
  7227952: 2043:	    inet = block[b_from].nets[blkpin];
        -: 2044:
  4570442: 2045:	    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   172120: 2046:		continue;
        -: 2047:
  4398322: 2048:	    if(net[inet].is_global)
        -: 2049:		continue;
  4398322: 2050:
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -: 2051:	    net_pin = net_pin_index[b_from][blkpin];
        -: 2052:
        -: 2053:	    if(net_pin != 0)
  2970668: 2054:		{
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
  2932322: 2055:
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2056:		    /*the following "if" prevents the value from being updated twice */
        -: 2057:		    if(net[inet].node_block[0] != b_to
  5864644: 2058:		       && net[inet].node_block[0] != b_from)
  2932322: 2059:			{
  2932322: 2060:
        -: 2061:			    point_to_point_delay_cost[inet][net_pin] =
        -: 2062:				temp_point_to_point_delay_cost[inet][net_pin];
  5864644: 2063:			    temp_point_to_point_delay_cost[inet][net_pin] =
  2932322: 2064:				-1;
  2932322: 2065:
  2932322: 2066:			    point_to_point_timing_cost[inet][net_pin] =
        -: 2067:				temp_point_to_point_timing_cost[inet]
        -: 2068:				[net_pin];
        -: 2069:			    temp_point_to_point_timing_cost[inet][net_pin] =
        -: 2070:				-1;
        -: 2071:			}
        -: 2072:		}
  5852366: 2073:	    else
branch  0 taken 76%
branch  1 taken 24% (fallthrough)
        -: 2074:		{		/*this net is being driven by a moved block, recompute */
        -: 2075:		    /*all point to point connections on this net. */
  8849424: 2076:		    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
  4424712: 2077:			{
  4424712: 2078:
        -: 2079:			    point_to_point_delay_cost[inet][ipin] =
  8849424: 2080:				temp_point_to_point_delay_cost[inet][ipin];
  4424712: 2081:			    temp_point_to_point_delay_cost[inet][ipin] = -1;
  4424712: 2082:
        -: 2083:			    point_to_point_timing_cost[inet][ipin] =
        -: 2084:				temp_point_to_point_timing_cost[inet][ipin];
        -: 2085:			    temp_point_to_point_timing_cost[inet][ipin] = -1;
        -: 2086:			}
   773930: 2087:		}
branch  0 taken 66% (fallthrough)
branch  1 taken 34%
        -: 2088:	}
  9729616: 2089:
branch  0 taken 95%
branch  1 taken 5% (fallthrough)
        -: 2090:    if(b_to != EMPTY)
        -: 2091:	{
  9217224: 2092:	    for(blkpin = 0; blkpin < num_of_pins; blkpin++)
        -: 2093:		{
  9217224: 2094:
branch  0 taken 55% (fallthrough)
branch  1 taken 45%
  5074780: 2095:		    inet = block[b_to].nets[blkpin];
        -: 2096:
  4142444: 2097:		    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   164926: 2098:			continue;
        -: 2099:
  3977518: 2100:		    if(net[inet].is_global)
        -: 2101:			continue;
  3977518: 2102:
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -: 2103:		    net_pin = net_pin_index[b_to][blkpin];
        -: 2104:
        -: 2105:		    if(net_pin != 0)
  2723462: 2106:			{
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
  2723462: 2107:
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 2108:			    /*the following "if" prevents the value from being updated 2x */
        -: 2109:			    if(net[inet].node_block[0] != b_to
  5369916: 2110:			       && net[inet].node_block[0] != b_from)
  2684958: 2111:				{
  2684958: 2112:
  2684958: 2113:				    point_to_point_delay_cost[inet][net_pin] =
  2684958: 2114:					temp_point_to_point_delay_cost[inet]
        -: 2115:					[net_pin];
  2684958: 2116:				    temp_point_to_point_delay_cost[inet]
  2684958: 2117:					[net_pin] = -1;
  2684958: 2118:
  2684958: 2119:				    point_to_point_timing_cost[inet][net_pin]
  2684958: 2120:					=
  2684958: 2121:					temp_point_to_point_timing_cost[inet]
        -: 2122:					[net_pin];
        -: 2123:				    temp_point_to_point_timing_cost[inet]
        -: 2124:					[net_pin] = -1;
        -: 2125:				}
        -: 2126:			}
  4509072: 2127:		    else
branch  0 taken 72%
branch  1 taken 28% (fallthrough)
        -: 2128:			{	/*this net is being driven by a moved block, recompute */
        -: 2129:			    /*all point to point connections on this net. */
  6510032: 2130:			    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
  3255016: 2131:				{
  3255016: 2132:
  3255016: 2133:				    point_to_point_delay_cost[inet][ipin] =
  3255016: 2134:					temp_point_to_point_delay_cost[inet]
        -: 2135:					[ipin];
  6510032: 2136:				    temp_point_to_point_delay_cost[inet][ipin]
  3255016: 2137:					= -1;
  3255016: 2138:
  3255016: 2139:				    point_to_point_timing_cost[inet][ipin] =
  3255016: 2140:					temp_point_to_point_timing_cost[inet]
        -: 2141:					[ipin];
        -: 2142:				    temp_point_to_point_timing_cost[inet]
        -: 2143:					[ipin] = -1;
        -: 2144:				}
   773930: 2145:			}
        -: 2146:		}
        -: 2147:	}
        -: 2148:}
function comp_delta_td_cost called 1696292 returned 100% blocks executed 100%
  1696292: 2149:
        -: 2150:
        -: 2151:static void
        -: 2152:comp_delta_td_cost(int b_from,
        -: 2153:		   int b_to,
        -: 2154:		   int num_of_pins,
        -: 2155:		   float *delta_timing,
        -: 2156:		   float *delta_delay)
        -: 2157:{
        -: 2158:
        -: 2159:    /*a net that is being driven by a moved block must have all of its  */
        -: 2160:    /*sink timing costs recomputed. A net that is driving a moved block */
        -: 2161:    /*must only have the timing cost on the connection driving the input */
        -: 2162:    /*pin computed */
        -: 2163:
  1696292: 2164:    int inet, k, net_pin, ipin;
  1696292: 2165:    float delta_timing_cost, delta_delay_cost, temp_delay;
        -: 2166:
        -: 2167:    delta_timing_cost = 0.;
 40117784: 2168:    delta_delay_cost = 0.;
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -: 2169:
 38421492: 2170:
        -: 2171:    for(k = 0; k < num_of_pins; k++)
 38421492: 2172:	{
branch  0 taken 47% (fallthrough)
branch  1 taken 53%
 18137800: 2173:	    inet = block[b_from].nets[k];
        -: 2174:
 20283692: 2175:	    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   780356: 2176:		continue;
        -: 2177:
 19503336: 2178:	    if(net[inet].is_global)
        -: 2179:		continue;
 19503336: 2180:
branch  0 taken 69% (fallthrough)
branch  1 taken 31%
        -: 2181:	    net_pin = net_pin_index[b_from][k];
        -: 2182:
        -: 2183:	    if(net_pin != 0)
        -: 2184:		{		/*this net is driving a moved block               */
        -: 2185:
        -: 2186:		    /*if this net is being driven by a block that has moved, we do not  */
        -: 2187:		    /*need to compute the change in the timing cost (here) since it will */
 13449622: 2188:		    /*be computed in the fanout of the net on  the driving block, also  */
branch  0 taken 98% (fallthrough)
branch  1 taken 2%
 13145420: 2189:		    /*computing it here would double count the change, and mess up the  */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2190:		    /*delta_timing_cost value */
 13145420: 2191:		    if(net[inet].node_block[0] != b_to
call    0 returned 100%
        -: 2192:		       && net[inet].node_block[0] != b_from)
        -: 2193:			{
 13145420: 2194:			    temp_delay =
        -: 2195:				comp_td_point_to_point_delay(inet, net_pin);
 26290840: 2196:
 13145420: 2197:			    temp_point_to_point_delay_cost[inet][net_pin] =
        -: 2198:				temp_delay;
 13145420: 2199:			    temp_point_to_point_timing_cost[inet][net_pin] =
 13145420: 2200:				timing_place_crit[inet][net_pin] * temp_delay;
 13145420: 2201:
        -: 2202:			    delta_delay_cost +=
 13145420: 2203:				temp_point_to_point_delay_cost[inet][net_pin]
 13145420: 2204:				- point_to_point_delay_cost[inet][net_pin];
 13145420: 2205:
        -: 2206:			    delta_timing_cost +=
        -: 2207:				temp_point_to_point_timing_cost[inet][net_pin]
        -: 2208:				- point_to_point_timing_cost[inet][net_pin];
        -: 2209:			}
        -: 2210:		}
 19365274: 2211:	    else
branch  0 taken 69%
branch  1 taken 31% (fallthrough)
        -: 2212:		{		/*this net is being driven by a moved block, recompute */
 13311560: 2213:		    /*all point to point connections on this net. */
call    0 returned 100%
        -: 2214:		    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
        -: 2215:			{
 13311560: 2216:			    temp_delay =
        -: 2217:				comp_td_point_to_point_delay(inet, ipin);
 26623120: 2218:
 13311560: 2219:			    temp_point_to_point_delay_cost[inet][ipin] =
        -: 2220:				temp_delay;
 13311560: 2221:			    temp_point_to_point_timing_cost[inet][ipin] =
 26623120: 2222:				timing_place_crit[inet][ipin] * temp_delay;
 13311560: 2223:
        -: 2224:			    delta_delay_cost +=
 13311560: 2225:				temp_point_to_point_delay_cost[inet][ipin] -
 26623120: 2226:				point_to_point_delay_cost[inet][ipin];
 13311560: 2227:
        -: 2228:			    delta_timing_cost +=
        -: 2229:				temp_point_to_point_timing_cost[inet][ipin] -
        -: 2230:				point_to_point_timing_cost[inet][ipin];
        -: 2231:			}
  1696292: 2232:		}
branch  0 taken 79% (fallthrough)
branch  1 taken 21%
        -: 2233:	}
 35351024: 2234:
branch  0 taken 96%
branch  1 taken 4% (fallthrough)
        -: 2235:    if(b_to != EMPTY)
 34009872: 2236:	{
        -: 2237:	    for(k = 0; k < num_of_pins; k++)
 34009872: 2238:		{
branch  0 taken 44% (fallthrough)
branch  1 taken 56%
 14883704: 2239:		    inet = block[b_to].nets[k];
        -: 2240:
 19126168: 2241:		    if(inet == OPEN)
branch  0 taken 4% (fallthrough)
branch  1 taken 96%
   763544: 2242:			continue;
        -: 2243:
 18362624: 2244:		    if(net[inet].is_global)
        -: 2245:			continue;
 18362624: 2246:
branch  0 taken 68% (fallthrough)
branch  1 taken 32%
        -: 2247:		    net_pin = net_pin_index[b_to][k];
        -: 2248:
        -: 2249:		    if(net_pin != 0)
        -: 2250:			{	/*this net is driving a moved block */
        -: 2251:
        -: 2252:			    /*if this net is being driven by a block that has moved, we do not */
        -: 2253:			    /*need to compute the change in the timing cost (here) since it was */
 12559512: 2254:			    /*computed in the fanout of the net on  the driving block, also    */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
 12559512: 2255:			    /*computing it here would double count the change, and mess up the */
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -: 2256:			    /*delta_timing_cost value */
 12198040: 2257:			    if(net[inet].node_block[0] != b_to
call    0 returned 100%
        -: 2258:			       && net[inet].node_block[0] != b_from)
        -: 2259:				{
        -: 2260:				    temp_delay =
 12198040: 2261:					comp_td_point_to_point_delay(inet,
 12198040: 2262:								     net_pin);
 12198040: 2263:
 24396080: 2264:				    temp_point_to_point_delay_cost[inet]
 12198040: 2265:					[net_pin] = temp_delay;
        -: 2266:				    temp_point_to_point_timing_cost[inet]
        -: 2267:					[net_pin] =
 12198040: 2268:					timing_place_crit[inet][net_pin] *
 12198040: 2269:					temp_delay;
 24396080: 2270:
 12198040: 2271:				    delta_delay_cost +=
 12198040: 2272:					temp_point_to_point_delay_cost[inet]
 12198040: 2273:					[net_pin] -
 12198040: 2274:					point_to_point_delay_cost[inet]
 24396080: 2275:					[net_pin];
 12198040: 2276:				    delta_timing_cost +=
 12198040: 2277:					temp_point_to_point_timing_cost[inet]
        -: 2278:					[net_pin] -
        -: 2279:					point_to_point_timing_cost[inet]
        -: 2280:					[net_pin];
        -: 2281:				}
        -: 2282:			}
 17998030: 2283:		    else
branch  0 taken 68%
branch  1 taken 32% (fallthrough)
        -: 2284:			{	/*this net is being driven by a moved block, recompute */
        -: 2285:			    /*all point to point connections on this net. */
 12194918: 2286:			    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
call    0 returned 100%
        -: 2287:				{
        -: 2288:
        -: 2289:				    temp_delay =
 12194918: 2290:					comp_td_point_to_point_delay(inet,
 12194918: 2291:								     ipin);
 12194918: 2292:
 24389836: 2293:				    temp_point_to_point_delay_cost[inet][ipin]
 12194918: 2294:					= temp_delay;
        -: 2295:				    temp_point_to_point_timing_cost[inet]
        -: 2296:					[ipin] =
        -: 2297:					timing_place_crit[inet][ipin] *
 12194918: 2298:					temp_delay;
 12194918: 2299:
 24389836: 2300:
 12194918: 2301:				    delta_delay_cost +=
 12194918: 2302:					temp_point_to_point_delay_cost[inet]
 12194918: 2303:					[ipin] -
 24389836: 2304:					point_to_point_delay_cost[inet][ipin];
 12194918: 2305:				    delta_timing_cost +=
 12194918: 2306:					temp_point_to_point_timing_cost[inet]
        -: 2307:					[ipin] -
        -: 2308:					point_to_point_timing_cost[inet]
        -: 2309:					[ipin];
        -: 2310:				}
        -: 2311:			}
  1696292: 2312:		}
  1696292: 2313:	}
  1696292: 2314:
        -: 2315:    *delta_timing = delta_timing_cost;
        -: 2316:    *delta_delay = delta_delay_cost;
function comp_td_costs called 278 returned 100% blocks executed 100%
      278: 2317:}
        -: 2318:
        -: 2319:static void
        -: 2320:comp_td_costs(float *timing_cost,
        -: 2321:	      float *connection_delay_sum)
        -: 2322:{
        -: 2323:    /*computes the cost (from scratch) due to the delays and criticalities*
        -: 2324:     *on all point to point connections, we define the timing cost of     *
        -: 2325:     *each connection as criticality*delay */
        -: 2326:
        -: 2327:    int inet, ipin;
      278: 2328:    float loc_timing_cost, loc_connection_delay_sum, temp_delay_cost,
      278: 2329:	temp_timing_cost;
        -: 2330:
   142336: 2331:    loc_timing_cost = 0.;
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2332:    loc_connection_delay_sum = 0.;
   142058: 2333:
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 2334:    for(inet = 0; inet < num_nets; inet++)
        -: 2335:	{			/* for each net ... */
   461758: 2336:	    if(net[inet].is_global == FALSE)
branch  0 taken 69%
branch  1 taken 31% (fallthrough)
        -: 2337:		{		/* Do only if not global. */
        -: 2338:
   319978: 2339:		    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
call    0 returned 100%
        -: 2340:			{
   319978: 2341:
        -: 2342:			    temp_delay_cost =
   319978: 2343:				comp_td_point_to_point_delay(inet, ipin);
        -: 2344:			    temp_timing_cost =
   319978: 2345:				temp_delay_cost *
   319978: 2346:				timing_place_crit[inet][ipin];
        -: 2347:
   319978: 2348:			    loc_connection_delay_sum += temp_delay_cost;
        -: 2349:			    point_to_point_delay_cost[inet][ipin] =
   319978: 2350:				temp_delay_cost;
        -: 2351:			    temp_point_to_point_delay_cost[inet][ipin] = -1;	/*undefined */
   319978: 2352:
   319978: 2353:			    point_to_point_timing_cost[inet][ipin] =
        -: 2354:				temp_timing_cost;
        -: 2355:			    temp_point_to_point_timing_cost[inet][ipin] = -1;	/*undefined */
        -: 2356:			    loc_timing_cost += temp_timing_cost;
      278: 2357:			}
      278: 2358:		}
      278: 2359:	}
        -: 2360:    *timing_cost = loc_timing_cost;
        -: 2361:    *connection_delay_sum = loc_connection_delay_sum;
        -: 2362:}
function comp_bb_cost called 4 returned 100% blocks executed 71%
        4: 2363:
        -: 2364:
        -: 2365:static float
        -: 2366:comp_bb_cost(int method,
        -: 2367:	     int place_cost_type,
        -: 2368:	     int num_regions)
        -: 2369:{
        -: 2370:
        -: 2371:    /* Finds the cost from scratch.  Done only when the placement   *
        -: 2372:     * has been radically changed (i.e. after initial placement).   *
        -: 2373:     * Otherwise find the cost change incrementally.  If method     *
        -: 2374:     * check is NORMAL, we find bounding boxes that are updateable  *
        -: 2375:     * for the larger nets.  If method is CHECK, all bounding boxes *
        -: 2376:     * are found via the non_updateable_bb routine, to provide a    *
        -: 2377:     * cost which can be used to check the correctness of the       *
        -: 2378:     * other routine.                                               */
        -: 2379:
        -: 2380:    int i, j, k;
        4: 2381:    float cost;
        4: 2382:    double expected_wirelength;
        -: 2383:
        -: 2384:    cost = 0;
        -: 2385:    expected_wirelength = 0.0;
        4: 2386:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2387:    /* Initialize occupancies to zero if regions are being used. */
    #####: 2388:
branch  0 never executed
branch  1 never executed
        -: 2389:    if(place_cost_type == NONLINEAR_CONG)
    #####: 2390:	{
branch  0 never executed
branch  1 never executed
        -: 2391:	    for(i = 0; i < num_regions; i++)
    #####: 2392:		{
    #####: 2393:		    for(j = 0; j < num_regions; j++)
        -: 2394:			{
        -: 2395:			    place_region_x[i][j].occupancy = 0.;
        -: 2396:			    place_region_y[i][j].occupancy = 0.;
        -: 2397:			}
     2048: 2398:		}
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2399:	}
        -: 2400:
     2044: 2401:    for(k = 0; k < num_nets; k++)
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
        -: 2402:	{			/* for each net ... */
        -: 2403:
        -: 2404:	    if(net[k].is_global == FALSE)
        -: 2405:		{		/* Do only if not global. */
        -: 2406:
     2040: 2407:		    /* Small nets don't use incremental updating on their bounding boxes, *
branch  0 taken 7% (fallthrough)
branch  1 taken 93%
branch  2 taken 50% (fallthrough)
branch  3 taken 50%
        -: 2408:		     * so they can use a fast bounding box calculator.                    */
      144: 2409:
call    0 returned 100%
       72: 2410:		    if(net[k].num_sinks >= SMALL_NET && method == NORMAL)
        -: 2411:			{
        -: 2412:			    get_bb_from_scratch(k, &bb_coords[k],
        -: 2413:						&bb_num_on_edges[k]);
     1968: 2414:			}
call    0 returned 100%
        -: 2415:		    else
        -: 2416:			{
     2040: 2417:			    get_non_updateable_bb(k, &bb_coords[k]);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2418:			}
     2040: 2419:
call    0 returned 100%
     2040: 2420:		    if(place_cost_type != NONLINEAR_CONG)
     2040: 2421:			{
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
     1020: 2422:			    net_cost[k] = get_net_cost(k, &bb_coords[k]);
     2040: 2423:			    cost += net_cost[k];
call    0 returned 100%
        -: 2424:			    if(method == CHECK)
     1020: 2425:				expected_wirelength +=
        -: 2426:				    get_net_wirelength_estimate(k,
        -: 2427:								&bb_coords
        -: 2428:								[k]);
    #####: 2429:			}
call    0 never executed
        -: 2430:		    else
        -: 2431:			{	/* Must be nonlinear_cong case. */
        -: 2432:			    update_region_occ(k, &bb_coords[k], 1,
        -: 2433:					      num_regions);
        -: 2434:			}
        4: 2435:		}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2436:	}
    #####: 2437:
call    0 never executed
        -: 2438:    if(place_cost_type == NONLINEAR_CONG)
        -: 2439:	{
        4: 2440:	    cost = nonlinear_cong_cost(num_regions);
branch  0 taken 50% (fallthrough)
branch  1 taken 50%
        2: 2441:	}
call    0 returned 100%
        -: 2442:
        -: 2443:    if(method == CHECK)
        4: 2444:	printf("BB estimate of min-dist (placement) wirelength is ;%.0f\n",
        -: 2445:	       expected_wirelength);
        -: 2446:
        -: 2447:    return (cost);
        -: 2448:}
function nonlinear_cong_cost called 0 returned 0% blocks executed 0%
    #####: 2449:
        -: 2450:
        -: 2451:static float
        -: 2452:nonlinear_cong_cost(int num_regions)
        -: 2453:{
        -: 2454:
        -: 2455:    /* This routine computes the cost of a placement when the NONLINEAR_CONG *
        -: 2456:     * option is selected.  It assumes that the occupancies of all the       *
        -: 2457:     * placement subregions have been properly updated, and simply           *
        -: 2458:     * computes the cost due to these occupancies by summing over all        *
        -: 2459:     * subregions.  This will be inefficient for moves that don't affect     *
        -: 2460:     * many subregions (i.e. small moves late in placement), esp. when there *
        -: 2461:     * are a lot of subregions.  May recode later to update only affected    *
        -: 2462:     * subregions.                                                           */
        -: 2463:
    #####: 2464:    float cost, tmp;
        -: 2465:    int i, j;
    #####: 2466:
branch  0 never executed
branch  1 never executed
        -: 2467:    cost = 0.;
    #####: 2468:
branch  0 never executed
branch  1 never executed
        -: 2469:    for(i = 0; i < num_regions; i++)
        -: 2470:	{
        -: 2471:	    for(j = 0; j < num_regions; j++)
        -: 2472:		{
    #####: 2473:
branch  0 never executed
branch  1 never executed
    #####: 2474:		    /* Many different cost metrics possible.  1st try:  */
        -: 2475:
    #####: 2476:		    if(place_region_x[i][j].occupancy <
    #####: 2477:		       place_region_x[i][j].capacity)
        -: 2478:			{
        -: 2479:			    cost += place_region_x[i][j].occupancy *
        -: 2480:				place_region_x[i][j].inv_capacity;
        -: 2481:			}
    #####: 2482:		    else
    #####: 2483:			{	/* Overused region -- penalize. */
    #####: 2484:
        -: 2485:			    tmp = place_region_x[i][j].occupancy *
        -: 2486:				place_region_x[i][j].inv_capacity;
    #####: 2487:			    cost += tmp * tmp;
branch  0 never executed
branch  1 never executed
    #####: 2488:			}
        -: 2489:
    #####: 2490:		    if(place_region_y[i][j].occupancy <
    #####: 2491:		       place_region_y[i][j].capacity)
        -: 2492:			{
        -: 2493:			    cost += place_region_y[i][j].occupancy *
        -: 2494:				place_region_y[i][j].inv_capacity;
        -: 2495:			}
    #####: 2496:		    else
    #####: 2497:			{	/* Overused region -- penalize. */
    #####: 2498:
        -: 2499:			    tmp = place_region_y[i][j].occupancy *
        -: 2500:				place_region_y[i][j].inv_capacity;
        -: 2501:			    cost += tmp * tmp;
        -: 2502:			}
        -: 2503:
    #####: 2504:		}
        -: 2505:	}
        -: 2506:
        -: 2507:    return (cost);
        -: 2508:}
function update_region_occ called 0 returned 0% blocks executed 0%
    #####: 2509:
        -: 2510:
        -: 2511:static void
        -: 2512:update_region_occ(int inet,
        -: 2513:		  struct s_bb *coords,
        -: 2514:		  int add_or_sub,
        -: 2515:		  int num_regions)
        -: 2516:{
        -: 2517:
        -: 2518:    /* Called only when the place_cost_type is NONLINEAR_CONG.  If add_or_sub *
        -: 2519:     * is 1, this uses the new net bounding box to increase the occupancy     *
        -: 2520:     * of some regions.  If add_or_sub = - 1, it decreases the occupancy      *
        -: 2521:     * by that due to this bounding box.                                      */
        -: 2522:
        -: 2523:    float net_xmin, net_xmax, net_ymin, net_ymax, crossing;
        -: 2524:    float inv_region_len, inv_region_height;
        -: 2525:    float inv_bb_len, inv_bb_height;
        -: 2526:    float overlap_xlow, overlap_xhigh, overlap_ylow, overlap_yhigh;
    #####: 2527:    float y_overlap, x_overlap, x_occupancy, y_occupancy;
branch  0 never executed
branch  1 never executed
        -: 2528:    int imin, imax, jmin, jmax, i, j;
    #####: 2529:
        -: 2530:    if(net[inet].num_sinks >= 50)
        -: 2531:	{
        -: 2532:	    crossing = 2.7933 + 0.02616 * ((net[inet].num_sinks + 1) - 50);
    #####: 2533:	}
        -: 2534:    else
        -: 2535:	{
    #####: 2536:	    crossing = cross_count[net[inet].num_sinks];
    #####: 2537:	}
    #####: 2538:
    #####: 2539:    net_xmin = coords->xmin - 0.5;
        -: 2540:    net_xmax = coords->xmax + 0.5;
        -: 2541:    net_ymin = coords->ymin - 0.5;
        -: 2542:    net_ymax = coords->ymax + 0.5;
    #####: 2543:
    #####: 2544:    /* I could precompute the two values below.  Should consider this. */
        -: 2545:
        -: 2546:    inv_region_len = (float)num_regions / (float)nx;
        -: 2547:    inv_region_height = (float)num_regions / (float)ny;
        -: 2548:
        -: 2549:    /* Get integer coordinates defining the rectangular area in which the *
        -: 2550:     * subregions have to be updated.  Formula is as follows:  subtract   *
        -: 2551:     * 0.5 from net_xmin, etc. to get numbers from 0 to nx or ny;         *
        -: 2552:     * divide by nx or ny to scale between 0 and 1; multiply by           *
    #####: 2553:     * num_regions to scale between 0 and num_regions; and truncate to    *
    #####: 2554:     * get the final answer.                                              */
    #####: 2555:
        -: 2556:    imin = (int)(net_xmin - 0.5) * inv_region_len;
    #####: 2557:    imax = (int)(net_xmax - 0.5) * inv_region_len;
    #####: 2558:    imax = min(imax, num_regions - 1);	/* Watch for weird roundoff */
    #####: 2559:
        -: 2560:    jmin = (int)(net_ymin - 0.5) * inv_region_height;
    #####: 2561:    jmax = (int)(net_ymax - 0.5) * inv_region_height;
    #####: 2562:    jmax = min(jmax, num_regions - 1);	/* Watch for weird roundoff */
        -: 2563:
        -: 2564:    inv_bb_len = 1. / (net_xmax - net_xmin);
        -: 2565:    inv_bb_height = 1. / (net_ymax - net_ymin);
        -: 2566:
    #####: 2567:    /* See RISA paper (ICCAD '94, pp. 690 - 695) for a description of why *
branch  0 never executed
branch  1 never executed
        -: 2568:     * I use exactly this cost function.                                  */
    #####: 2569:
branch  0 never executed
branch  1 never executed
        -: 2570:    for(i = imin; i <= imax; i++)
    #####: 2571:	{
branch  0 never executed
branch  1 never executed
    #####: 2572:	    for(j = jmin; j <= jmax; j++)
    #####: 2573:		{
branch  0 never executed
branch  1 never executed
    #####: 2574:		    overlap_xlow = max(place_region_bounds_x[i], net_xmin);
branch  0 never executed
branch  1 never executed
    #####: 2575:		    overlap_xhigh =
    #####: 2576:			min(place_region_bounds_x[i + 1], net_xmax);
branch  0 never executed
branch  1 never executed
        -: 2577:		    overlap_ylow = max(place_region_bounds_y[j], net_ymin);
    #####: 2578:		    overlap_yhigh =
    #####: 2579:			min(place_region_bounds_y[j + 1], net_ymax);
        -: 2580:
        -: 2581:		    x_overlap = overlap_xhigh - overlap_xlow;
        -: 2582:		    y_overlap = overlap_yhigh - overlap_ylow;
    #####: 2583:
branch  0 never executed
branch  1 never executed
        -: 2584:#ifdef DEBUG
    #####: 2585:
call    0 never executed
        -: 2586:		    if(x_overlap < -0.001)
        -: 2587:			{
        -: 2588:			    printf
        -: 2589:				("Error in update_region_occ:  x_overlap < 0"
        -: 2590:				 "\n inet = %d, overlap = %g\n", inet,
    #####: 2591:				 x_overlap);
branch  0 never executed
branch  1 never executed
        -: 2592:			}
    #####: 2593:
call    0 never executed
        -: 2594:		    if(y_overlap < -0.001)
        -: 2595:			{
        -: 2596:			    printf
        -: 2597:				("Error in update_region_occ:  y_overlap < 0"
        -: 2598:				 "\n inet = %d, overlap = %g\n", inet,
        -: 2599:				 y_overlap);
        -: 2600:			}
    #####: 2601:#endif
    #####: 2602:
        -: 2603:
    #####: 2604:		    x_occupancy =
    #####: 2605:			crossing * y_overlap * x_overlap * inv_bb_height *
        -: 2606:			inv_region_len;
        -: 2607:		    y_occupancy =
    #####: 2608:			crossing * x_overlap * y_overlap * inv_bb_len *
    #####: 2609:			inv_region_height;
    #####: 2610:
    #####: 2611:		    place_region_x[i][j].occupancy +=
        -: 2612:			add_or_sub * x_occupancy;
        -: 2613:		    place_region_y[i][j].occupancy +=
        -: 2614:			add_or_sub * y_occupancy;
    #####: 2615:		}
        -: 2616:	}
        -: 2617:
        -: 2618:}
function free_place_regions called 0 returned 0% blocks executed 0%
    #####: 2619:
        -: 2620:
        -: 2621:static void
        -: 2622:free_place_regions(int num_regions)
        -: 2623:{
        -: 2624:
    #####: 2625:    /* Frees the place_regions data structures needed by the NONLINEAR_CONG *
call    0 never executed
        -: 2626:     * cost function.                                                       */
        -: 2627:
    #####: 2628:    free_matrix(place_region_x, 0, num_regions - 1, 0, sizeof(struct
call    0 never executed
        -: 2629:							      s_place_region));
        -: 2630:
    #####: 2631:    free_matrix(place_region_y, 0, num_regions - 1, 0, sizeof(struct
    #####: 2632:							      s_place_region));
    #####: 2633:
        -: 2634:    free(place_region_bounds_x);
        -: 2635:    free(place_region_bounds_y);
        -: 2636:}
function free_placement_structs called 2 returned 100% blocks executed 73%
        2: 2637:
        -: 2638:
        -: 2639:static void
        -: 2640:free_placement_structs(int place_cost_type,
        -: 2641:		       int num_regions,
        -: 2642:		       float **old_region_occ_x,
        -: 2643:		       float **old_region_occ_y,
        -: 2644:		       struct s_placer_opts placer_opts)
        -: 2645:{
        -: 2646:
        -: 2647:    /* Frees the major structures needed by the placer (and not needed       *
        -: 2648:     * elsewhere).   */
        4: 2649:
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 2650:    int inet;
branch  0 never executed
branch  1 never executed
    #####: 2651:
        -: 2652:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
     1024: 2653:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE ||
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2654:       placer_opts.enable_timing_computations)
        -: 2655:	{
        -: 2656:	    for(inet = 0; inet < num_nets; inet++)
     1022: 2657:		{
     1022: 2658:		    /*add one to the address since it is indexed from 1 not 0 */
        -: 2659:
     1022: 2660:		    point_to_point_delay_cost[inet]++;
     1022: 2661:		    free(point_to_point_delay_cost[inet]);
        -: 2662:
     1022: 2663:		    point_to_point_timing_cost[inet]++;
     1022: 2664:		    free(point_to_point_timing_cost[inet]);
        -: 2665:
     1022: 2666:		    temp_point_to_point_delay_cost[inet]++;
     1022: 2667:		    free(temp_point_to_point_delay_cost[inet]);
        -: 2668:
        2: 2669:		    temp_point_to_point_timing_cost[inet]++;
        2: 2670:		    free(temp_point_to_point_timing_cost[inet]);
        -: 2671:		}
        2: 2672:	    free(point_to_point_delay_cost);
        2: 2673:	    free(temp_point_to_point_delay_cost);
        -: 2674:
        2: 2675:	    free(point_to_point_timing_cost);
call    0 returned 100%
        -: 2676:	    free(temp_point_to_point_timing_cost);
        -: 2677:
        -: 2678:	    free_matrix(net_pin_index, 0, num_blocks - 1, 0, sizeof(int));
        2: 2679:	}
        2: 2680:
        2: 2681:
        2: 2682:    free(net_cost);
        -: 2683:    free(temp_net_cost);
        2: 2684:    free(bb_num_on_edges);
        2: 2685:    free(bb_coords);
        2: 2686:
        2: 2687:    net_cost = NULL;		/* Defensive coding. */
        -: 2688:    temp_net_cost = NULL;
        2: 2689:    bb_num_on_edges = NULL;
call    0 returned 100%
        -: 2690:    bb_coords = NULL;
        2: 2691:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2692:    free_unique_pin_list();
    #####: 2693:
call    0 never executed
    #####: 2694:    if(place_cost_type == NONLINEAR_CONG)
call    0 never executed
        -: 2695:	{
    #####: 2696:	    free_place_regions(num_regions);
call    0 never executed
        -: 2697:	    free_matrix(old_region_occ_x, 0, num_regions - 1, 0,
        -: 2698:			sizeof(float));
        -: 2699:	    free_matrix(old_region_occ_y, 0, num_regions - 1, 0,
        2: 2700:			sizeof(float));
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2701:	}
        2: 2702:
call    0 returned 100%
        -: 2703:    else if(place_cost_type == LINEAR_CONG)
        2: 2704:	{
        -: 2705:	    free_fast_cost_update_structs();
        -: 2706:	}
        -: 2707:}
function alloc_and_load_placement_structs called 2 returned 100% blocks executed 86%
        2: 2708:
        -: 2709:
        -: 2710:static void
        -: 2711:alloc_and_load_placement_structs(int place_cost_type,
        -: 2712:				 int num_regions,
        -: 2713:				 float place_cost_exp,
        -: 2714:				 float ***old_region_occ_x,
        -: 2715:				 float ***old_region_occ_y,
        -: 2716:				 struct s_placer_opts placer_opts)
        -: 2717:{
        -: 2718:
        -: 2719:    /* Allocates the major structures needed only by the placer, primarily for *
        -: 2720:     * computing costs quickly and such.                                       */
        2: 2721:
       10: 2722:    int inet, ipin, max_pins_per_fb, i;
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 2723:
        8: 2724:    max_pins_per_fb = 0;
        8: 2725:    for(i = 0; i < num_types; i++)
        -: 2726:	{
        -: 2727:	    max_pins_per_fb =
        4: 2728:		max(max_pins_per_fb, type_descriptors[i].num_pins);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        2: 2729:	}
branch  0 never executed
branch  1 never executed
    #####: 2730:
        -: 2731:    if(placer_opts.place_algorithm == NET_TIMING_DRIVEN_PLACE ||
        -: 2732:       placer_opts.place_algorithm == PATH_TIMING_DRIVEN_PLACE ||
        -: 2733:       placer_opts.enable_timing_computations)
        2: 2734:	{
        2: 2735:	    /*allocate structures associated with timing driven placement */
call    0 returned 100%
        2: 2736:	    /* [0..num_nets-1][1..num_pins-1]  */
        2: 2737:	    point_to_point_delay_cost =
call    0 returned 100%
        -: 2738:		(float **)my_malloc(num_nets * sizeof(float *));
        2: 2739:	    temp_point_to_point_delay_cost =
        2: 2740:		(float **)my_malloc(num_nets * sizeof(float *));
call    0 returned 100%
        2: 2741:
        2: 2742:	    point_to_point_timing_cost =
call    0 returned 100%
        -: 2743:		(float **)my_malloc(num_nets * sizeof(float *));
        2: 2744:	    temp_point_to_point_timing_cost =
        2: 2745:		(float **)my_malloc(num_nets * sizeof(float *));
call    0 returned 100%
        -: 2746:
        -: 2747:	    net_pin_index =
     1024: 2748:		(int **)alloc_matrix(0, num_blocks - 1, 0,
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2749:				     max_pins_per_fb - 1, sizeof(int));
        -: 2750:
        -: 2751:	    for(inet = 0; inet < num_nets; inet++)
        -: 2752:		{
     2044: 2753:
     1022: 2754:		    /* in the following, subract one so index starts at *
call    0 returned 100%
        -: 2755:		     * 1 instead of 0 */
     1022: 2756:		    point_to_point_delay_cost[inet] =
        -: 2757:			(float *)my_malloc(net[inet].num_sinks *
     2044: 2758:					   sizeof(float));
     1022: 2759:		    point_to_point_delay_cost[inet]--;
call    0 returned 100%
        -: 2760:
     1022: 2761:		    temp_point_to_point_delay_cost[inet] =
        -: 2762:			(float *)my_malloc(net[inet].num_sinks *
     2044: 2763:					   sizeof(float));
     1022: 2764:		    temp_point_to_point_delay_cost[inet]--;
call    0 returned 100%
        -: 2765:
     1022: 2766:		    point_to_point_timing_cost[inet] =
        -: 2767:			(float *)my_malloc(net[inet].num_sinks *
     2044: 2768:					   sizeof(float));
     1022: 2769:		    point_to_point_timing_cost[inet]--;
call    0 returned 100%
        -: 2770:
     1022: 2771:		    temp_point_to_point_timing_cost[inet] =
        -: 2772:			(float *)my_malloc(net[inet].num_sinks *
     1024: 2773:					   sizeof(float));
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2774:		    temp_point_to_point_timing_cost[inet]--;
     3448: 2775:		}
branch  0 taken 70%
branch  1 taken 30% (fallthrough)
        -: 2776:	    for(inet = 0; inet < num_nets; inet++)
     2426: 2777:		{
     2426: 2778:		    for(ipin = 1; ipin <= net[inet].num_sinks; ipin++)
        -: 2779:			{
        -: 2780:			    point_to_point_delay_cost[inet][ipin] = 0;
        -: 2781:			    temp_point_to_point_delay_cost[inet][ipin] = 0;
        -: 2782:			}
        -: 2783:		}
        -: 2784:	}
        -: 2785:
        -: 2786:
        2: 2787:
call    0 returned 100%
        2: 2788:
call    0 returned 100%
        -: 2789:
        -: 2790:    net_cost = (float *)my_malloc(num_nets * sizeof(float));
        -: 2791:    temp_net_cost = (float *)my_malloc(num_nets * sizeof(float));
        -: 2792:
        -: 2793:    /* Used to store costs for moves not yet made and to indicate when a net's   *
     1024: 2794:     * cost has been recomputed. temp_net_cost[inet] < 0 means net's cost hasn't *
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
     1022: 2795:     * been recomputed.                                                          */
        -: 2796:
        2: 2797:    for(inet = 0; inet < num_nets; inet++)
call    0 returned 100%
        2: 2798:	temp_net_cost[inet] = -1.;
        2: 2799:
call    0 returned 100%
        -: 2800:    bb_coords = (struct s_bb *)my_malloc(num_nets * sizeof(struct s_bb));
        -: 2801:    bb_num_on_edges =
        -: 2802:	(struct s_bb *)my_malloc(num_nets * sizeof(struct s_bb));
        2: 2803:
call    0 returned 100%
        -: 2804:    /* Get a list of pins with no duplicates. */
        -: 2805:
        -: 2806:    alloc_and_load_unique_pin_list();
        2: 2807:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 2808:    /* Allocate storage for subregion data, if needed. */
    #####: 2809:
call    0 never executed
    #####: 2810:    if(place_cost_type == NONLINEAR_CONG)
call    0 never executed
    #####: 2811:	{
call    0 never executed
        -: 2812:	    alloc_place_regions(num_regions);
        -: 2813:	    load_place_regions(num_regions);
    #####: 2814:	    *old_region_occ_x = (float **)alloc_matrix(0, num_regions - 1, 0,
    #####: 2815:						       num_regions - 1,
call    0 never executed
        -: 2816:						       sizeof(float));
        -: 2817:	    *old_region_occ_y =
        -: 2818:		(float **)alloc_matrix(0, num_regions - 1, 0, num_regions - 1,
        -: 2819:				       sizeof(float));
        2: 2820:	}
        2: 2821:    else
        -: 2822:	{			/* Shouldn't use them; crash hard if I do!   */
        -: 2823:	    *old_region_occ_x = NULL;
        2: 2824:	    *old_region_occ_y = NULL;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 2825:	}
        2: 2826:
call    0 returned 100%
        -: 2827:    if(place_cost_type == LINEAR_CONG)
        2: 2828:	{
        -: 2829:	    alloc_and_load_for_fast_cost_update(place_cost_exp);
        -: 2830:	}
        -: 2831:}
function alloc_place_regions called 0 returned 0% blocks executed 0%
    #####: 2832:
        -: 2833:
        -: 2834:static void
        -: 2835:alloc_place_regions(int num_regions)
        -: 2836:{
        -: 2837:
        -: 2838:    /* Allocates memory for the regional occupancy, cost, etc. counts *
    #####: 2839:     * kept when we're using the NONLINEAR_CONG placement cost        *
    #####: 2840:     * function.                                                      */
call    0 never executed
        -: 2841:
        -: 2842:    place_region_x =
        -: 2843:	(struct s_place_region **)alloc_matrix(0, num_regions - 1, 0,
    #####: 2844:					       num_regions - 1,
    #####: 2845:					       sizeof(struct s_place_region));
call    0 never executed
        -: 2846:
        -: 2847:    place_region_y =
        -: 2848:	(struct s_place_region **)alloc_matrix(0, num_regions - 1, 0,
    #####: 2849:					       num_regions - 1,
call    0 never executed
        -: 2850:					       sizeof(struct s_place_region));
        -: 2851:
    #####: 2852:    place_region_bounds_x = (float *)my_malloc((num_regions + 1) *
call    0 never executed
        -: 2853:					       sizeof(float));
    #####: 2854:
        -: 2855:    place_region_bounds_y = (float *)my_malloc((num_regions + 1) *
        -: 2856:					       sizeof(float));
        -: 2857:}
function load_place_regions called 0 returned 0% blocks executed 0%
    #####: 2858:
        -: 2859:
        -: 2860:static void
        -: 2861:load_place_regions(int num_regions)
        -: 2862:{
        -: 2863:
        -: 2864:    /* Loads the capacity values in each direction for each of the placement *
        -: 2865:     * regions.  The chip is divided into a num_regions x num_regions array. */
        -: 2866:
        -: 2867:    int i, j, low_block, high_block, rnum;
        -: 2868:    float low_lim, high_lim, capacity, fac, block_capacity;
        -: 2869:    float len_fac, height_fac;
    #####: 2870:
branch  0 never executed
branch  1 never executed
        -: 2871:    /* First load up horizontal channel capacities.  */
    #####: 2872:
    #####: 2873:    for(j = 0; j < num_regions; j++)
    #####: 2874:	{
        -: 2875:	    capacity = 0.;
    #####: 2876:	    low_lim = (float)j / (float)num_regions *ny + 1.;
    #####: 2877:	    high_lim = (float)(j + 1) / (float)num_regions *ny;
    #####: 2878:
    #####: 2879:	    low_block = floor(low_lim);
        -: 2880:	    low_block = max(1, low_block);	/* Watch for weird roundoff effects. */
    #####: 2881:	    high_block = ceil(high_lim);
    #####: 2882:	    high_block = min(high_block, ny);
    #####: 2883:
branch  0 never executed
branch  1 never executed
    #####: 2884:	    block_capacity = (chan_width_x[low_block - 1] +
        -: 2885:			      chan_width_x[low_block]) / 2.;
    #####: 2886:	    if(low_block == 1)
    #####: 2887:		block_capacity += chan_width_x[0] / 2.;
        -: 2888:
    #####: 2889:	    fac = 1. - (low_lim - low_block);
branch  0 never executed
branch  1 never executed
        -: 2890:	    capacity += fac * block_capacity;
    #####: 2891:
    #####: 2892:	    for(rnum = low_block + 1; rnum < high_block; rnum++)
    #####: 2893:		{
        -: 2894:		    block_capacity =
        -: 2895:			(chan_width_x[rnum - 1] + chan_width_x[rnum]) / 2.;
    #####: 2896:		    capacity += block_capacity;
    #####: 2897:		}
    #####: 2898:
branch  0 never executed
branch  1 never executed
    #####: 2899:	    block_capacity = (chan_width_x[high_block - 1] +
        -: 2900:			      chan_width_x[high_block]) / 2.;
    #####: 2901:	    if(high_block == ny)
    #####: 2902:		block_capacity += chan_width_x[ny] / 2.;
        -: 2903:
    #####: 2904:	    fac = 1. - (high_block - high_lim);
branch  0 never executed
branch  1 never executed
        -: 2905:	    capacity += fac * block_capacity;
    #####: 2906:
    #####: 2907:	    for(i = 0; i < num_regions; i++)
    #####: 2908:		{
    #####: 2909:		    place_region_x[i][j].capacity = capacity;
        -: 2910:		    place_region_x[i][j].inv_capacity = 1. / capacity;
        -: 2911:		    place_region_x[i][j].occupancy = 0.;
        -: 2912:		    place_region_x[i][j].cost = 0.;
        -: 2913:		}
        -: 2914:	}
    #####: 2915:
branch  0 never executed
branch  1 never executed
        -: 2916:    /* Now load vertical channel capacities.  */
    #####: 2917:
    #####: 2918:    for(i = 0; i < num_regions; i++)
    #####: 2919:	{
        -: 2920:	    capacity = 0.;
    #####: 2921:	    low_lim = (float)i / (float)num_regions *nx + 1.;
    #####: 2922:	    high_lim = (float)(i + 1) / (float)num_regions *nx;
    #####: 2923:
    #####: 2924:	    low_block = floor(low_lim);
        -: 2925:	    low_block = max(1, low_block);	/* Watch for weird roundoff effects. */
    #####: 2926:	    high_block = ceil(high_lim);
    #####: 2927:	    high_block = min(high_block, nx);
    #####: 2928:
branch  0 never executed
branch  1 never executed
    #####: 2929:	    block_capacity = (chan_width_y[low_block - 1] +
        -: 2930:			      chan_width_y[low_block]) / 2.;
    #####: 2931:	    if(low_block == 1)
    #####: 2932:		block_capacity += chan_width_y[0] / 2.;
        -: 2933:
    #####: 2934:	    fac = 1. - (low_lim - low_block);
branch  0 never executed
branch  1 never executed
        -: 2935:	    capacity += fac * block_capacity;
    #####: 2936:
    #####: 2937:	    for(rnum = low_block + 1; rnum < high_block; rnum++)
    #####: 2938:		{
        -: 2939:		    block_capacity =
        -: 2940:			(chan_width_y[rnum - 1] + chan_width_y[rnum]) / 2.;
    #####: 2941:		    capacity += block_capacity;
    #####: 2942:		}
    #####: 2943:
branch  0 never executed
branch  1 never executed
    #####: 2944:	    block_capacity = (chan_width_y[high_block - 1] +
        -: 2945:			      chan_width_y[high_block]) / 2.;
    #####: 2946:	    if(high_block == nx)
    #####: 2947:		block_capacity += chan_width_y[nx] / 2.;
        -: 2948:
    #####: 2949:	    fac = 1. - (high_block - high_lim);
branch  0 never executed
branch  1 never executed
        -: 2950:	    capacity += fac * block_capacity;
    #####: 2951:
    #####: 2952:	    for(j = 0; j < num_regions; j++)
    #####: 2953:		{
    #####: 2954:		    place_region_y[i][j].capacity = capacity;
        -: 2955:		    place_region_y[i][j].inv_capacity = 1. / capacity;
        -: 2956:		    place_region_y[i][j].occupancy = 0.;
        -: 2957:		    place_region_y[i][j].cost = 0.;
        -: 2958:		}
        -: 2959:	}
        -: 2960:
    #####: 2961:    /* Finally set up the arrays indicating the limits of each of the *
    #####: 2962:     * placement subregions.                                          */
        -: 2963:
    #####: 2964:    len_fac = (float)nx / (float)num_regions;
    #####: 2965:    height_fac = (float)ny / (float)num_regions;
        -: 2966:
    #####: 2967:    place_region_bounds_x[0] = 0.5;
branch  0 never executed
branch  1 never executed
        -: 2968:    place_region_bounds_y[0] = 0.5;
    #####: 2969:
    #####: 2970:    for(i = 1; i <= num_regions; i++)
    #####: 2971:	{
        -: 2972:	    place_region_bounds_x[i] = place_region_bounds_x[i - 1] + len_fac;
    #####: 2973:	    place_region_bounds_y[i] =
        -: 2974:		place_region_bounds_y[i - 1] + height_fac;
        -: 2975:	}
        -: 2976:}
function free_unique_pin_list called 2 returned 100% blocks executed 100%
        2: 2977:
        -: 2978:
        -: 2979:static void
        -: 2980:free_unique_pin_list(void)
        -: 2981:{
        -: 2982:
        -: 2983:    /* Frees the unique pin list structures.                               */
        2: 2984:
        -: 2985:    int any_dup, inet;
     1024: 2986:
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 2987:    any_dup = 0;
     1022: 2988:
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 2989:    for(inet = 0; inet < num_nets; inet++)
        2: 2990:	{
        2: 2991:	    if(duplicate_pins[inet] != 0)
        -: 2992:		{
        -: 2993:		    free(unique_pin_list[inet]);
        -: 2994:		    any_dup = 1;
        2: 2995:		}
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        2: 2996:	}
        -: 2997:
        2: 2998:    if(any_dup != 0)
        2: 2999:	free(unique_pin_list);
        -: 3000:
        -: 3001:    free(duplicate_pins);
        -: 3002:}
function alloc_and_load_unique_pin_list called 2 returned 100% blocks executed 100%
        2: 3003:
        -: 3004:
        -: 3005:static void
        -: 3006:alloc_and_load_unique_pin_list(void)
        -: 3007:{
        -: 3008:
        -: 3009:    /* This routine looks for multiple pins going to the same block in the *
        -: 3010:     * pinlist of each net.  If it finds any, it marks that net as having  *
        -: 3011:     * duplicate pins, and creates a new pinlist with no duplicates.  This *
        -: 3012:     * is then used by the updatable bounding box calculation routine for  *
        -: 3013:     * efficiency.                                                         */
        -: 3014:
        -: 3015:    int inet, ipin, bnum, num_dup, any_dups, offset;
        2: 3016:    int *times_listed;		/* [0..num_blocks-1]: number of times a block is   *
call    0 returned 100%
        2: 3017:				 * * listed in the pinlist of a net.  Temp. storage. */
call    0 returned 100%
        2: 3018:
        -: 3019:    duplicate_pins = my_calloc(num_nets, sizeof(int));
     1024: 3020:    times_listed = my_calloc(num_blocks, sizeof(int));
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3021:    any_dups = 0;
        -: 3022:
     1022: 3023:    for(inet = 0; inet < num_nets; inet++)
        -: 3024:	{
     4470: 3025:
branch  0 taken 77%
branch  1 taken 23% (fallthrough)
        -: 3026:	    num_dup = 0;
     3448: 3027:
     3448: 3028:	    for(ipin = 0; ipin <= net[inet].num_sinks; ipin++)
     3448: 3029:		{
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
      194: 3030:		    bnum = net[inet].node_block[ipin];
        -: 3031:		    times_listed[bnum]++;
        -: 3032:		    if(times_listed[bnum] > 1)
     1022: 3033:			num_dup++;
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 3034:		}
        2: 3035:
        -: 3036:	    if(num_dup > 0)
        2: 3037:		{		/* Duplicates found.  Make unique pin list. */
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3038:		    duplicate_pins[inet] = num_dup;
        2: 3039:
        2: 3040:		    if(any_dups == 0)
call    0 returned 100%
        2: 3041:			{	/* This is the first duplicate found */
        -: 3042:			    unique_pin_list =
        -: 3043:				(int **)my_calloc(num_nets, sizeof(int *));
        4: 3044:			    any_dups = 1;
        2: 3045:			}
call    0 returned 100%
        -: 3046:
        -: 3047:		    unique_pin_list[inet] =
        2: 3048:			my_malloc((net[inet].num_sinks + 1 -
      208: 3049:				   num_dup) * sizeof(int));
branch  0 taken 99%
branch  1 taken 1%
        -: 3050:
      206: 3051:		    offset = 0;
      206: 3052:		    for(ipin = 0; ipin <= net[inet].num_sinks; ipin++)
branch  0 taken 6% (fallthrough)
branch  1 taken 94%
        -: 3053:			{
       12: 3054:			    bnum = net[inet].node_block[ipin];
       12: 3055:			    if(times_listed[bnum] != 0)
       12: 3056:				{
        -: 3057:				    times_listed[bnum] = 0;
        -: 3058:				    unique_pin_list[inet][offset] = bnum;
        -: 3059:				    offset++;
        -: 3060:				}
        -: 3061:			}
        -: 3062:		}
     4262: 3063:
branch  0 taken 76%
branch  1 taken 24% (fallthrough)
        -: 3064:	    else
     3242: 3065:		{		/* No duplicates found.  Reset times_listed. */
     3242: 3066:		    for(ipin = 0; ipin <= net[inet].num_sinks; ipin++)
        -: 3067:			{
        -: 3068:			    bnum = net[inet].node_block[ipin];
        -: 3069:			    times_listed[bnum] = 0;
        -: 3070:			}
        2: 3071:		}
        2: 3072:	}
        -: 3073:
        -: 3074:    free((void *)times_listed);
        -: 3075:}
function get_bb_from_scratch called 630400 returned 100% blocks executed 100%
   630400: 3076:
        -: 3077:
        -: 3078:static void
        -: 3079:get_bb_from_scratch(int inet,
        -: 3080:		    struct s_bb *coords,
        -: 3081:		    struct s_bb *num_on_edges)
        -: 3082:{
        -: 3083:
        -: 3084:    /* This routine finds the bounding box of each net from scratch (i.e.    *
        -: 3085:     * from only the block location information).  It updates both the       *
        -: 3086:     * coordinate and number of blocks on each edge information.  It         *
        -: 3087:     * should only be called when the bounding box information is not valid. */
        -: 3088:
        -: 3089:    int ipin, bnum, x, y, xmin, xmax, ymin, ymax;
        -: 3090:    int xmin_edge, xmax_edge, ymin_edge, ymax_edge;
        -: 3091:    int n_pins;
        -: 3092:    int *plist;
        -: 3093:
        -: 3094:    /* I need a list of blocks to which this net connects, with no block listed *
   630400: 3095:     * more than once, in order to get a proper count of the number on the edge *
branch  0 taken 97% (fallthrough)
branch  1 taken 3%
        -: 3096:     * of the bounding box.                                                     */
   611850: 3097:
   611850: 3098:    if(duplicate_pins[inet] == 0)
        -: 3099:	{
        -: 3100:	    plist = net[inet].node_block;
        -: 3101:	    n_pins = net[inet].num_sinks + 1;
    18550: 3102:	}
    18550: 3103:    else
        -: 3104:	{
        -: 3105:	    plist = unique_pin_list[inet];
   630400: 3106:	    n_pins = (net[inet].num_sinks + 1) - duplicate_pins[inet];
   630400: 3107:	}
        -: 3108:
   630400: 3109:    x = block[plist[0]].x;
   630400: 3110:    y = block[plist[0]].y;
        -: 3111:
   630400: 3112:    x = max(min(x, nx), 1);
   630400: 3113:    y = max(min(y, ny), 1);
   630400: 3114:
   630400: 3115:    xmin = x;
   630400: 3116:    ymin = y;
   630400: 3117:    xmax = x;
   630400: 3118:    ymax = y;
   630400: 3119:    xmin_edge = 1;
        -: 3120:    ymin_edge = 1;
  4801918: 3121:    xmax_edge = 1;
branch  0 taken 87%
branch  1 taken 13% (fallthrough)
        -: 3122:    ymax_edge = 1;
        -: 3123:
  4171518: 3124:    for(ipin = 1; ipin < n_pins; ipin++)
  4171518: 3125:	{
  4171518: 3126:
        -: 3127:	    bnum = plist[ipin];
        -: 3128:	    x = block[bnum].x;
        -: 3129:	    y = block[bnum].y;
        -: 3130:
        -: 3131:	    /* Code below counts IO blocks as being within the 1..nx, 1..ny clb array. *
        -: 3132:	     * This is because channels do not go out of the 0..nx, 0..ny range, and   *
        -: 3133:	     * I always take all channels impinging on the bounding box to be within   *
        -: 3134:	     * that bounding box.  Hence, this "movement" of IO blocks does not affect *
  4171518: 3135:	     * the which channels are included within the bounding box, and it         *
  4171518: 3136:	     * simplifies the code a lot.                                              */
        -: 3137:
  4171518: 3138:	    x = max(min(x, nx), 1);
branch  0 taken 20% (fallthrough)
branch  1 taken 80%
        -: 3139:	    y = max(min(y, ny), 1);
   818306: 3140:
        -: 3141:	    if(x == xmin)
  4171518: 3142:		{
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -: 3143:		    xmin_edge++;
   665096: 3144:		}
        -: 3145:	    if(x == xmax)
  3506422: 3146:		{		/* Recall that xmin could equal xmax -- don't use else */
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        -: 3147:		    xmax_edge++;
   648118: 3148:		}
   648118: 3149:	    else if(x < xmin)
        -: 3150:		{
  2858304: 3151:		    xmin = x;
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -: 3152:		    xmin_edge = 1;
   714832: 3153:		}
   714832: 3154:	    else if(x > xmax)
        -: 3155:		{
        -: 3156:		    xmax = x;
  4171518: 3157:		    xmax_edge = 1;
branch  0 taken 12% (fallthrough)
branch  1 taken 88%
        -: 3158:		}
   484684: 3159:
        -: 3160:	    if(y == ymin)
  4171518: 3161:		{
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -: 3162:		    ymin_edge++;
   607180: 3163:		}
        -: 3164:	    if(y == ymax)
  3564338: 3165:		{
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -: 3166:		    ymax_edge++;
   741294: 3167:		}
   741294: 3168:	    else if(y < ymin)
        -: 3169:		{
  2823044: 3170:		    ymin = y;
branch  0 taken 25% (fallthrough)
branch  1 taken 75%
        -: 3171:		    ymin_edge = 1;
   711214: 3172:		}
   711214: 3173:	    else if(y > ymax)
        -: 3174:		{
        -: 3175:		    ymax = y;
        -: 3176:		    ymax_edge = 1;
        -: 3177:		}
        -: 3178:	}
        -: 3179:
   630400: 3180:    /* Copy the coordinates and number on edges information into the proper   *
   630400: 3181:     * structures.                                                            */
   630400: 3182:
   630400: 3183:    coords->xmin = xmin;
        -: 3184:    coords->xmax = xmax;
   630400: 3185:    coords->ymin = ymin;
   630400: 3186:    coords->ymax = ymax;
   630400: 3187:
   630400: 3188:    num_on_edges->xmin = xmin_edge;
   630400: 3189:    num_on_edges->xmax = xmax_edge;
        -: 3190:    num_on_edges->ymin = ymin_edge;
        -: 3191:    num_on_edges->ymax = ymax_edge;
        -: 3192:}
function get_net_wirelength_estimate called 1020 returned 100% blocks executed 88%
     1020: 3193:
        -: 3194:
        -: 3195:static double
        -: 3196:get_net_wirelength_estimate(int inet,
        -: 3197:			    struct s_bb *bbptr)
        -: 3198:{
        -: 3199:
        -: 3200:    /* WMF: Finds the estimate of wirelength due to one net by looking at   *
        -: 3201:     * its coordinate bounding box.                                         */
        -: 3202:
        -: 3203:    double ncost, crossing;
        -: 3204:
     1020: 3205:    /* Get the expected "crossing count" of a net, based on its number *
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 3206:     * of pins.  Extrapolate for very large nets.                      */
    #####: 3207:
        -: 3208:    if(((net[inet].num_sinks + 1) > 50) && ((net[inet].num_sinks + 1) < 85))
     1020: 3209:	{
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 3210:	    crossing = 2.7933 + 0.02616 * ((net[inet].num_sinks + 1) - 50);
        2: 3211:	}
        2: 3212:    else if((net[inet].num_sinks + 1) >= 85)
        2: 3213:	{
        -: 3214:	    crossing =
        -: 3215:		2.7933 + 0.011 * (net[inet].num_sinks + 1) -
        -: 3216:		0.0000018 * (net[inet].num_sinks + 1) * (net[inet].num_sinks +
        -: 3217:							 1);
     1018: 3218:	}
        -: 3219:    else
        -: 3220:	{
        -: 3221:	    crossing = cross_count[(net[inet].num_sinks + 1) - 1];
        -: 3222:	}
        -: 3223:
        -: 3224:    /* Could insert a check for xmin == xmax.  In that case, assume  *
        -: 3225:     * connection will be made with no bends and hence no x-cost.    *
        -: 3226:     * Same thing for y-cost.                                        */
        -: 3227:
     1020: 3228:    /* Cost = wire length along channel * cross_count / average      *
        -: 3229:     * channel capacity.   Do this for x, then y direction and add.  */
     1020: 3230:
        -: 3231:    ncost = (bbptr->xmax - bbptr->xmin + 1) * crossing;
     1020: 3232:
        -: 3233:    ncost += (bbptr->ymax - bbptr->ymin + 1) * crossing;
        -: 3234:
        -: 3235:    return (ncost);
        -: 3236:}
function get_net_cost called 31275570 returned 100% blocks executed 100%
 31275570: 3237:
        -: 3238:
        -: 3239:static float
        -: 3240:get_net_cost(int inet,
        -: 3241:	     struct s_bb *bbptr)
        -: 3242:{
        -: 3243:
        -: 3244:    /* Finds the cost due to one net by looking at its coordinate bounding  *
        -: 3245:     * box.                                                                 */
        -: 3246:
        -: 3247:    float ncost, crossing;
        -: 3248:
 31275570: 3249:    /* Get the expected "crossing count" of a net, based on its number *
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        -: 3250:     * of pins.  Extrapolate for very large nets.                      */
    38700: 3251:
        -: 3252:    if((net[inet].num_sinks + 1) > 50)
        -: 3253:	{
        -: 3254:	    crossing = 2.7933 + 0.02616 * ((net[inet].num_sinks + 1) - 50);
        -: 3255:	    /*    crossing = 3.0;    Old value  */
 31236870: 3256:	}
        -: 3257:    else
        -: 3258:	{
        -: 3259:	    crossing = cross_count[(net[inet].num_sinks + 1) - 1];
        -: 3260:	}
        -: 3261:
        -: 3262:    /* Could insert a check for xmin == xmax.  In that case, assume  *
        -: 3263:     * connection will be made with no bends and hence no x-cost.    *
        -: 3264:     * Same thing for y-cost.                                        */
        -: 3265:
 62551140: 3266:    /* Cost = wire length along channel * cross_count / average      *
 31275570: 3267:     * channel capacity.   Do this for x, then y direction and add.  */
        -: 3268:
 62551140: 3269:    ncost = (bbptr->xmax - bbptr->xmin + 1) * crossing *
 31275570: 3270:	chanx_place_cost_fac[bbptr->ymax][bbptr->ymin - 1];
        -: 3271:
 31275570: 3272:    ncost += (bbptr->ymax - bbptr->ymin + 1) * crossing *
        -: 3273:	chany_place_cost_fac[bbptr->xmax][bbptr->xmin - 1];
        -: 3274:
        -: 3275:    return (ncost);
        -: 3276:}
function get_non_updateable_bb called 25259404 returned 100% blocks executed 100%
 25259404: 3277:
        -: 3278:
        -: 3279:static void
        -: 3280:get_non_updateable_bb(int inet,
        -: 3281:		      struct s_bb *bb_coord_new)
        -: 3282:{
        -: 3283:
        -: 3284:    /* Finds the bounding box of a net and stores its coordinates in the  *
        -: 3285:     * bb_coord_new data structure.  This routine should only be called   *
        -: 3286:     * for small nets, since it does not determine enough information for *
        -: 3287:     * the bounding box to be updated incrementally later.                *
        -: 3288:     * Currently assumes channels on both sides of the CLBs forming the   *
        -: 3289:     * edges of the bounding box can be used.  Essentially, I am assuming *
        -: 3290:     * the pins always lie on the outside of the bounding box.            */
        -: 3291:
 25259404: 3292:
 25259404: 3293:    int k, xmax, ymax, xmin, ymin, x, y;
        -: 3294:
 25259404: 3295:    x = block[net[inet].node_block[0]].x;
 25259404: 3296:    y = block[net[inet].node_block[0]].y;
 25259404: 3297:
 25259404: 3298:    xmin = x;
        -: 3299:    ymin = y;
 64443236: 3300:    xmax = x;
branch  0 taken 61%
branch  1 taken 39% (fallthrough)
        -: 3301:    ymax = y;
 39183832: 3302:
 39183832: 3303:    for(k = 1; k < (net[inet].num_sinks + 1); k++)
        -: 3304:	{
 39183832: 3305:	    x = block[net[inet].node_block[k]].x;
branch  0 taken 35% (fallthrough)
branch  1 taken 65%
        -: 3306:	    y = block[net[inet].node_block[k]].y;
 13729632: 3307:
        -: 3308:	    if(x < xmin)
 25454200: 3309:		{
branch  0 taken 61% (fallthrough)
branch  1 taken 39%
        -: 3310:		    xmin = x;
 15491918: 3311:		}
        -: 3312:	    else if(x > xmax)
        -: 3313:		{
 39183832: 3314:		    xmax = x;
branch  0 taken 38% (fallthrough)
branch  1 taken 62%
        -: 3315:		}
 14869256: 3316:
        -: 3317:	    if(y < ymin)
 24314576: 3318:		{
branch  0 taken 58% (fallthrough)
branch  1 taken 42%
        -: 3319:		    ymin = y;
 14137244: 3320:		}
        -: 3321:	    else if(y > ymax)
        -: 3322:		{
        -: 3323:		    ymax = y;
        -: 3324:		}
        -: 3325:	}
        -: 3326:
        -: 3327:    /* Now I've found the coordinates of the bounding box.  There are no *
        -: 3328:     * channels beyond nx and ny, so I want to clip to that.  As well,   *
        -: 3329:     * since I'll always include the channel immediately below and the   *
        -: 3330:     * channel immediately to the left of the bounding box, I want to    *
 25259404: 3331:     * clip to 1 in both directions as well (since minimum channel index *
 25259404: 3332:     * is 0).  See route.c for a channel diagram.                        */
 25259404: 3333:
 25259404: 3334:    bb_coord_new->xmin = max(min(xmin, nx), 1);
 25259404: 3335:    bb_coord_new->ymin = max(min(ymin, ny), 1);
        -: 3336:    bb_coord_new->xmax = max(min(xmax, nx), 1);
        -: 3337:    bb_coord_new->ymax = max(min(ymax, ny), 1);
        -: 3338:}
function update_bb called 6016094 returned 100% blocks executed 100%
  6016094: 3339:
        -: 3340:
        -: 3341:static void
        -: 3342:update_bb(int inet,
        -: 3343:	  struct s_bb *bb_coord_new,
        -: 3344:	  struct s_bb *bb_edge_new,
        -: 3345:	  int xold,
        -: 3346:	  int yold,
        -: 3347:	  int xnew,
        -: 3348:	  int ynew)
        -: 3349:{
        -: 3350:
        -: 3351:    /* Updates the bounding box of a net by storing its coordinates in    *
        -: 3352:     * the bb_coord_new data structure and the number of blocks on each   *
        -: 3353:     * edge in the bb_edge_new data structure.  This routine should only  *
        -: 3354:     * be called for large nets, since it has some overhead relative to   *
        -: 3355:     * just doing a brute force bounding box calculation.  The bounding   *
        -: 3356:     * box coordinate and edge information for inet must be valid before  *
        -: 3357:     * this routine is called.                                            *
        -: 3358:     * Currently assumes channels on both sides of the CLBs forming the   *
        -: 3359:     * edges of the bounding box can be used.  Essentially, I am assuming *
        -: 3360:     * the pins always lie on the outside of the bounding box.            */
  6016094: 3361:
  6016094: 3362:    /* IO blocks are considered to be one cell in for simplicity. */
  6016094: 3363:
  6016094: 3364:    xnew = max(min(xnew, nx), 1);
        -: 3365:    ynew = max(min(ynew, ny), 1);
        -: 3366:    xold = max(min(xold, nx), 1);
        -: 3367:    yold = max(min(yold, ny), 1);
  6016094: 3368:
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
        -: 3369:    /* Check if I can update the bounding box incrementally. */
        -: 3370:
        -: 3371:    if(xnew < xold)
        -: 3372:	{			/* Move to left. */
  1999088: 3373:
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -: 3374:	    /* Update the xmax fields for coordinates and number of edges first. */
   725786: 3375:
branch  0 taken 23% (fallthrough)
branch  1 taken 77%
        -: 3376:	    if(xold == bb_coords[inet].xmax)
   167400: 3377:		{		/* Old position at xmax. */
call    0 returned 100%
        -: 3378:		    if(bb_num_on_edges[inet].xmax == 1)
   167400: 3379:			{
        -: 3380:			    get_bb_from_scratch(inet, bb_coord_new,
        -: 3381:						bb_edge_new);
        -: 3382:			    return;
   558386: 3383:			}
   558386: 3384:		    else
   558386: 3385:			{
        -: 3386:			    bb_edge_new->xmax =
        -: 3387:				bb_num_on_edges[inet].xmax - 1;
        -: 3388:			    bb_coord_new->xmax = bb_coords[inet].xmax;
        -: 3389:			}
        -: 3390:		}
  1273302: 3391:
  1273302: 3392:	    else
        -: 3393:		{		/* Move to left, old postion was not at xmax. */
        -: 3394:		    bb_coord_new->xmax = bb_coords[inet].xmax;
        -: 3395:		    bb_edge_new->xmax = bb_num_on_edges[inet].xmax;
        -: 3396:		}
  1831688: 3397:
branch  0 taken 17% (fallthrough)
branch  1 taken 83%
        -: 3398:	    /* Now do the xmin fields for coordinates and number of edges. */
   305018: 3399:
   305018: 3400:	    if(xnew < bb_coords[inet].xmin)
        -: 3401:		{		/* Moved past xmin */
        -: 3402:		    bb_coord_new->xmin = xnew;
  1526670: 3403:		    bb_edge_new->xmin = 1;
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
        -: 3404:		}
   451352: 3405:
   451352: 3406:	    else if(xnew == bb_coords[inet].xmin)
        -: 3407:		{		/* Moved to xmin */
        -: 3408:		    bb_coord_new->xmin = xnew;
        -: 3409:		    bb_edge_new->xmin = bb_num_on_edges[inet].xmin + 1;
        -: 3410:		}
  1075318: 3411:
  1075318: 3412:	    else
        -: 3413:		{		/* Xmin unchanged. */
        -: 3414:		    bb_coord_new->xmin = bb_coords[inet].xmin;
        -: 3415:		    bb_edge_new->xmin = bb_num_on_edges[inet].xmin;
        -: 3416:		}
  4017006: 3417:	}
branch  0 taken 65% (fallthrough)
branch  1 taken 35%
        -: 3418:
        -: 3419:    /* End of move to left case. */
        -: 3420:    else if(xnew > xold)
        -: 3421:	{			/* Move to right. */
  2596924: 3422:
branch  0 taken 30% (fallthrough)
branch  1 taken 70%
        -: 3423:	    /* Update the xmin fields for coordinates and number of edges first. */
   785824: 3424:
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -: 3425:	    if(xold == bb_coords[inet].xmin)
   121128: 3426:		{		/* Old position at xmin. */
call    0 returned 100%
        -: 3427:		    if(bb_num_on_edges[inet].xmin == 1)
   121128: 3428:			{
        -: 3429:			    get_bb_from_scratch(inet, bb_coord_new,
        -: 3430:						bb_edge_new);
        -: 3431:			    return;
   664696: 3432:			}
   664696: 3433:		    else
   664696: 3434:			{
        -: 3435:			    bb_edge_new->xmin =
        -: 3436:				bb_num_on_edges[inet].xmin - 1;
        -: 3437:			    bb_coord_new->xmin = bb_coords[inet].xmin;
        -: 3438:			}
        -: 3439:		}
  1811100: 3440:
  1811100: 3441:	    else
        -: 3442:		{		/* Move to right, old position was not at xmin. */
        -: 3443:		    bb_coord_new->xmin = bb_coords[inet].xmin;
        -: 3444:		    bb_edge_new->xmin = bb_num_on_edges[inet].xmin;
        -: 3445:		}
  2475796: 3446:
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -: 3447:	    /* Now do the xmax fields for coordinates and number of edges. */
   665024: 3448:
   665024: 3449:	    if(xnew > bb_coords[inet].xmax)
        -: 3450:		{		/* Moved past xmax. */
        -: 3451:		    bb_coord_new->xmax = xnew;
  1810772: 3452:		    bb_edge_new->xmax = 1;
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
        -: 3453:		}
   656036: 3454:
   656036: 3455:	    else if(xnew == bb_coords[inet].xmax)
        -: 3456:		{		/* Moved to xmax */
        -: 3457:		    bb_coord_new->xmax = xnew;
        -: 3458:		    bb_edge_new->xmax = bb_num_on_edges[inet].xmax + 1;
        -: 3459:		}
  1154736: 3460:
  1154736: 3461:	    else
        -: 3462:		{		/* Xmax unchanged. */
        -: 3463:		    bb_coord_new->xmax = bb_coords[inet].xmax;
        -: 3464:		    bb_edge_new->xmax = bb_num_on_edges[inet].xmax;
        -: 3465:		}
        -: 3466:	}
  1420082: 3467:    /* End of move to right case. */
  1420082: 3468:    else
  1420082: 3469:	{			/* xnew == xold -- no x motion. */
  1420082: 3470:	    bb_coord_new->xmin = bb_coords[inet].xmin;
        -: 3471:	    bb_coord_new->xmax = bb_coords[inet].xmax;
        -: 3472:	    bb_edge_new->xmin = bb_num_on_edges[inet].xmin;
        -: 3473:	    bb_edge_new->xmax = bb_num_on_edges[inet].xmax;
        -: 3474:	}
  5727566: 3475:
branch  0 taken 48% (fallthrough)
branch  1 taken 52%
        -: 3476:    /* Now account for the y-direction motion. */
        -: 3477:
        -: 3478:    if(ynew < yold)
        -: 3479:	{			/* Move down. */
  2731320: 3480:
branch  0 taken 18% (fallthrough)
branch  1 taken 82%
        -: 3481:	    /* Update the ymax fields for coordinates and number of edges first. */
   487260: 3482:
branch  0 taken 29% (fallthrough)
branch  1 taken 71%
        -: 3483:	    if(yold == bb_coords[inet].ymax)
   138924: 3484:		{		/* Old position at ymax. */
call    0 returned 100%
        -: 3485:		    if(bb_num_on_edges[inet].ymax == 1)
   138924: 3486:			{
        -: 3487:			    get_bb_from_scratch(inet, bb_coord_new,
        -: 3488:						bb_edge_new);
        -: 3489:			    return;
   348336: 3490:			}
   348336: 3491:		    else
   348336: 3492:			{
        -: 3493:			    bb_edge_new->ymax =
        -: 3494:				bb_num_on_edges[inet].ymax - 1;
        -: 3495:			    bb_coord_new->ymax = bb_coords[inet].ymax;
        -: 3496:			}
        -: 3497:		}
  2244060: 3498:
  2244060: 3499:	    else
        -: 3500:		{		/* Move down, old postion was not at ymax. */
        -: 3501:		    bb_coord_new->ymax = bb_coords[inet].ymax;
        -: 3502:		    bb_edge_new->ymax = bb_num_on_edges[inet].ymax;
        -: 3503:		}
  2592396: 3504:
branch  0 taken 27% (fallthrough)
branch  1 taken 73%
        -: 3505:	    /* Now do the ymin fields for coordinates and number of edges. */
   690452: 3506:
   690452: 3507:	    if(ynew < bb_coords[inet].ymin)
        -: 3508:		{		/* Moved past ymin */
        -: 3509:		    bb_coord_new->ymin = ynew;
  1901944: 3510:		    bb_edge_new->ymin = 1;
branch  0 taken 21% (fallthrough)
branch  1 taken 79%
        -: 3511:		}
   405262: 3512:
   405262: 3513:	    else if(ynew == bb_coords[inet].ymin)
        -: 3514:		{		/* Moved to ymin */
        -: 3515:		    bb_coord_new->ymin = ynew;
        -: 3516:		    bb_edge_new->ymin = bb_num_on_edges[inet].ymin + 1;
        -: 3517:		}
  1496682: 3518:
  1496682: 3519:	    else
        -: 3520:		{		/* ymin unchanged. */
        -: 3521:		    bb_coord_new->ymin = bb_coords[inet].ymin;
        -: 3522:		    bb_edge_new->ymin = bb_num_on_edges[inet].ymin;
  2996246: 3523:		}
branch  0 taken 72% (fallthrough)
branch  1 taken 28%
        -: 3524:	}
        -: 3525:    /* End of move down case. */
        -: 3526:    else if(ynew > yold)
        -: 3527:	{			/* Moved up. */
  2150526: 3528:
branch  0 taken 28% (fallthrough)
branch  1 taken 72%
        -: 3529:	    /* Update the ymin fields for coordinates and number of edges first. */
   599574: 3530:
branch  0 taken 34% (fallthrough)
branch  1 taken 66%
        -: 3531:	    if(yold == bb_coords[inet].ymin)
   202876: 3532:		{		/* Old position at ymin. */
call    0 returned 100%
        -: 3533:		    if(bb_num_on_edges[inet].ymin == 1)
   202876: 3534:			{
        -: 3535:			    get_bb_from_scratch(inet, bb_coord_new,
        -: 3536:						bb_edge_new);
        -: 3537:			    return;
   396698: 3538:			}
   396698: 3539:		    else
   396698: 3540:			{
        -: 3541:			    bb_edge_new->ymin =
        -: 3542:				bb_num_on_edges[inet].ymin - 1;
        -: 3543:			    bb_coord_new->ymin = bb_coords[inet].ymin;
        -: 3544:			}
        -: 3545:		}
  1550952: 3546:
  1550952: 3547:	    else
        -: 3548:		{		/* Moved up, old position was not at ymin. */
        -: 3549:		    bb_coord_new->ymin = bb_coords[inet].ymin;
        -: 3550:		    bb_edge_new->ymin = bb_num_on_edges[inet].ymin;
        -: 3551:		}
  1947650: 3552:
branch  0 taken 15% (fallthrough)
branch  1 taken 85%
        -: 3553:	    /* Now do the ymax fields for coordinates and number of edges. */
   283234: 3554:
   283234: 3555:	    if(ynew > bb_coords[inet].ymax)
        -: 3556:		{		/* Moved past ymax. */
        -: 3557:		    bb_coord_new->ymax = ynew;
  1664416: 3558:		    bb_edge_new->ymax = 1;
branch  0 taken 16% (fallthrough)
branch  1 taken 84%
        -: 3559:		}
   259638: 3560:
   259638: 3561:	    else if(ynew == bb_coords[inet].ymax)
        -: 3562:		{		/* Moved to ymax */
        -: 3563:		    bb_coord_new->ymax = ynew;
        -: 3564:		    bb_edge_new->ymax = bb_num_on_edges[inet].ymax + 1;
        -: 3565:		}
  1404778: 3566:
  1404778: 3567:	    else
        -: 3568:		{		/* ymax unchanged. */
        -: 3569:		    bb_coord_new->ymax = bb_coords[inet].ymax;
        -: 3570:		    bb_edge_new->ymax = bb_num_on_edges[inet].ymax;
        -: 3571:		}
        -: 3572:	}
   845720: 3573:    /* End of move up case. */
   845720: 3574:    else
   845720: 3575:	{			/* ynew == yold -- no y motion. */
   845720: 3576:	    bb_coord_new->ymin = bb_coords[inet].ymin;
        -: 3577:	    bb_coord_new->ymax = bb_coords[inet].ymax;
        -: 3578:	    bb_edge_new->ymin = bb_num_on_edges[inet].ymin;
        -: 3579:	    bb_edge_new->ymax = bb_num_on_edges[inet].ymax;
        -: 3580:	}
        -: 3581:}
function initial_placement called 2 returned 100% blocks executed 95%
        2: 3582:
        -: 3583:
        -: 3584:static void
        -: 3585:initial_placement(enum e_pad_loc_type pad_loc_type,
        -: 3586:		  char *pad_loc_file)
        -: 3587:{
        -: 3588:
        -: 3589:    /* Randomly places the blocks to create an initial placement.     */
        -: 3590:    struct s_pos
        -: 3591:    {
        -: 3592:	int x;
        -: 3593:	int y;
        -: 3594:	int z;
        -: 3595:    }
        -: 3596:    **pos;			/* [0..num_types-1][0..type_tsize - 1] */
        2: 3597:    int i, j, k, iblk, choice, type_index, x, y, z;
call    0 returned 100%
        2: 3598:    int *count, *index;		/* [0..num_types-1] */
call    0 returned 100%
        2: 3599:
call    0 returned 100%
        -: 3600:    pos = (struct s_pos **)my_malloc(num_types * sizeof(struct s_pos *));
        -: 3601:    count = (int *)my_calloc(num_types, sizeof(int));
        -: 3602:    index = (int *)my_calloc(num_types, sizeof(int));
       26: 3603:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3604:    /* Initialize all occupancy to zero. */
      312: 3605:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3606:    for(i = 0; i <= nx + 1; i++)
      288: 3607:	{
      722: 3608:	    for(j = 0; j <= ny + 1; j++)
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        -: 3609:		{
      434: 3610:		    grid[i][j].usage = 0;
      434: 3611:		    for(k = 0; k < grid[i][j].type->capacity; k++)
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 3612:			{
      398: 3613:			    grid[i][j].blocks[k] = EMPTY;
        -: 3614:			    if(grid[i][j].offset == 0)
        -: 3615:				{
        -: 3616:				    count[grid[i][j].type->index]++;
        -: 3617:				}
        -: 3618:			}
       10: 3619:		}
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 3620:	}
       16: 3621:
        8: 3622:    for(i = 0; i < num_types; i++)
call    0 returned 100%
        -: 3623:	{
        -: 3624:	    pos[i] =
       26: 3625:		(struct s_pos *)my_malloc(count[i] * sizeof(struct s_pos));
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3626:	}
      312: 3627:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3628:    for(i = 0; i <= nx + 1; i++)
      722: 3629:	{
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        -: 3630:	    for(j = 0; j <= ny + 1; j++)
      434: 3631:		{
branch  0 taken 92% (fallthrough)
branch  1 taken 8%
        -: 3632:		    for(k = 0; k < grid[i][j].type->capacity; k++)
      398: 3633:			{
      398: 3634:			    if(grid[i][j].offset == 0)
      398: 3635:				{
      398: 3636:				    type_index = grid[i][j].type->index;
      398: 3637:				    pos[type_index][index[type_index]].x = i;
        -: 3638:				    pos[type_index][index[type_index]].y = j;
        -: 3639:				    pos[type_index][index[type_index]].z = k;
        -: 3640:				    index[type_index]++;
        -: 3641:				}
        -: 3642:			}
      278: 3643:		}
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -: 3644:	}
        -: 3645:
      276: 3646:    for(iblk = 0; iblk < num_blocks; iblk++)
branch  0 taken 46% (fallthrough)
branch  1 taken 54%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3647:	{
      276: 3648:	    /* Don't do IOs if the user specifies IOs */
      276: 3649:	    if(!(block[iblk].type == IO_TYPE && pad_loc_type == USER))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      276: 3650:		{
call    0 returned 100%
      276: 3651:		    type_index = block[iblk].type->index;
      276: 3652:		    assert(count[type_index] > 0);
      276: 3653:		    choice = my_irand(count[type_index] - 1);
      276: 3654:		    x = pos[type_index][choice].x;
      276: 3655:		    y = pos[type_index][choice].y;
        -: 3656:		    z = pos[type_index][choice].z;
        -: 3657:		    grid[x][y].blocks[z] = iblk;
      276: 3658:		    grid[x][y].usage++;
      276: 3659:
        -: 3660:		    /* Ensure randomizer doesn't pick this block again */
        -: 3661:		    pos[type_index][choice] = pos[type_index][count[type_index] - 1];	/* overwrite used block position */
        -: 3662:		    count[type_index]--;
        2: 3663:		}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3664:	}
    #####: 3665:
call    0 never executed
        -: 3666:    if(pad_loc_type == USER)
        -: 3667:	{
        -: 3668:	    read_user_pad_loc(pad_loc_file);
        -: 3669:	}
        -: 3670:
       26: 3671:    /* All the blocks are placed now.  Make the block array agree with the    *
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3672:     * clb array.                                                             */
      312: 3673:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3674:    for(i = 0; i <= (nx + 1); i++)
      722: 3675:	{
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        -: 3676:	    for(j = 0; j <= (ny + 1); j++)
      434: 3677:		{
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
      434: 3678:		    for(k = 0; k < grid[i][j].type->capacity; k++)
        -: 3679:			{
      434: 3680:			    assert(grid[i][j].blocks != NULL);
branch  0 taken 64% (fallthrough)
branch  1 taken 36%
        -: 3681:			    iblk = grid[i][j].blocks[k];
      276: 3682:
      276: 3683:			    if(iblk != EMPTY)
      276: 3684:				{
        -: 3685:				    block[iblk].x = i;
        -: 3686:				    block[iblk].y = j;
        -: 3687:				    block[iblk].z = k;
        -: 3688:				}
        -: 3689:			}
        -: 3690:		}
        -: 3691:	}
        -: 3692:
        -: 3693:#ifdef VERBOSE
       10: 3694:    printf("At end of initial_placement.\n");
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
        -: 3695:    dump_clbs();
        8: 3696:#endif
        -: 3697:    for(i = 0; i < num_types; i++)
        2: 3698:	{
        2: 3699:	    free(pos[i]);
        2: 3700:	}
        2: 3701:    free(pos);			/* Free the mapping list */
        -: 3702:    free(index);
        -: 3703:    free(count);
        -: 3704:}
function free_fast_cost_update_structs called 2 returned 100% blocks executed 100%
        2: 3705:
        -: 3706:
        -: 3707:static void
        -: 3708:free_fast_cost_update_structs(void)
        -: 3709:{
        -: 3710:
        -: 3711:    /* Frees the structures used to speed up evaluation of the nonlinear   *
        -: 3712:     * congestion cost function.                                           */
       24: 3713:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
       22: 3714:    int i;
        -: 3715:
        2: 3716:    for(i = 0; i <= ny; i++)
        -: 3717:	free(chanx_place_cost_fac[i]);
       24: 3718:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
       22: 3719:    free(chanx_place_cost_fac);
        -: 3720:
        2: 3721:    for(i = 0; i <= nx; i++)
        2: 3722:	free(chany_place_cost_fac[i]);
        -: 3723:
        -: 3724:    free(chany_place_cost_fac);
        -: 3725:}
function alloc_and_load_for_fast_cost_update called 2 returned 100% blocks executed 100%
        2: 3726:
        -: 3727:
        -: 3728:static void
        -: 3729:alloc_and_load_for_fast_cost_update(float place_cost_exp)
        -: 3730:{
        -: 3731:
        -: 3732:    /* Allocates and loads the chanx_place_cost_fac and chany_place_cost_fac *
        -: 3733:     * arrays with the inverse of the average number of tracks per channel   *
        -: 3734:     * between [subhigh] and [sublow].  This is only useful for the cost     *
        -: 3735:     * function that takes the length of the net bounding box in each        *
        -: 3736:     * dimension divided by the average number of tracks in that direction.  *
        -: 3737:     * For other cost functions, you don't have to bother calling this       *
        -: 3738:     * routine; when using the cost function described above, however, you   *
        -: 3739:     * must always call this routine after you call init_chan and before     *
        -: 3740:     * you do any placement cost determination.  The place_cost_exp factor   *
        -: 3741:     * specifies to what power the width of the channel should be taken --   *
        -: 3742:     * larger numbers make narrower channels more expensive.                 */
        -: 3743:
        -: 3744:    int low, high, i;
        -: 3745:
        -: 3746:    /* Access arrays below as chan?_place_cost_fac[subhigh][sublow].  Since   *
        2: 3747:     * subhigh must be greater than or equal to sublow, we only need to       *
call    0 returned 100%
       24: 3748:     * allocate storage for the lower half of a matrix.                       */
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
       22: 3749:
call    0 returned 100%
        -: 3750:    chanx_place_cost_fac = (float **)my_malloc((ny + 1) * sizeof(float *));
        2: 3751:    for(i = 0; i <= ny; i++)
call    0 returned 100%
       24: 3752:	chanx_place_cost_fac[i] = (float *)my_malloc((i + 1) * sizeof(float));
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
       22: 3753:
call    0 returned 100%
        -: 3754:    chany_place_cost_fac = (float **)my_malloc((nx + 1) * sizeof(float *));
        -: 3755:    for(i = 0; i <= nx; i++)
        -: 3756:	chany_place_cost_fac[i] = (float *)my_malloc((i + 1) * sizeof(float));
        -: 3757:
        -: 3758:
        2: 3759:    /* First compute the number of tracks between channel high and channel *
        -: 3760:     * low, inclusive, in an efficient manner.                             */
       22: 3761:
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -: 3762:    chanx_place_cost_fac[0][0] = chan_width_x[0];
       20: 3763:
      130: 3764:    for(high = 1; high <= ny; high++)
branch  0 taken 85%
branch  1 taken 15% (fallthrough)
        -: 3765:	{
      220: 3766:	    chanx_place_cost_fac[high][high] = chan_width_x[high];
      220: 3767:	    for(low = 0; low < high; low++)
      110: 3768:		{
        -: 3769:		    chanx_place_cost_fac[high][low] =
        -: 3770:			chanx_place_cost_fac[high - 1][low] +
        -: 3771:			chan_width_x[high];
        -: 3772:		}
        -: 3773:	}
        -: 3774:
        -: 3775:    /* Now compute the inverse of the average number of tracks per channel *
        -: 3776:     * between high and low.  The cost function divides by the average     *
        -: 3777:     * number of tracks per channel, so by storing the inverse I convert   *
        -: 3778:     * this to a faster multiplication.  Take this final number to the     *
        -: 3779:     * place_cost_exp power -- numbers other than one mean this is no      *
       24: 3780:     * longer a simple "average number of tracks"; it is some power of     *
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
      154: 3781:     * that, allowing greater penalization of narrow channels.             */
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -: 3782:
      264: 3783:    for(high = 0; high <= ny; high++)
      132: 3784:	for(low = 0; low <= high; low++)
      264: 3785:	    {
      132: 3786:		chanx_place_cost_fac[high][low] = (high - low + 1.) /
        -: 3787:		    chanx_place_cost_fac[high][low];
        -: 3788:		chanx_place_cost_fac[high][low] =
        -: 3789:		    pow((double)chanx_place_cost_fac[high][low],
        -: 3790:			(double)place_cost_exp);
        -: 3791:	    }
        -: 3792:
        -: 3793:
        2: 3794:    /* Now do the same thing for the y-directed channels.  First get the  *
        -: 3795:     * number of tracks between channel high and channel low, inclusive.  */
       22: 3796:
branch  0 taken 91%
branch  1 taken 9% (fallthrough)
        -: 3797:    chany_place_cost_fac[0][0] = chan_width_y[0];
       20: 3798:
      130: 3799:    for(high = 1; high <= nx; high++)
branch  0 taken 85%
branch  1 taken 15% (fallthrough)
        -: 3800:	{
      220: 3801:	    chany_place_cost_fac[high][high] = chan_width_y[high];
      220: 3802:	    for(low = 0; low < high; low++)
      110: 3803:		{
        -: 3804:		    chany_place_cost_fac[high][low] =
        -: 3805:			chany_place_cost_fac[high - 1][low] +
        -: 3806:			chan_width_y[high];
        -: 3807:		}
        -: 3808:	}
        -: 3809:
       24: 3810:    /* Now compute the inverse of the average number of tracks per channel * 
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
      154: 3811:     * between high and low.  Take to specified power.                     */
branch  0 taken 86%
branch  1 taken 14% (fallthrough)
        -: 3812:
      264: 3813:    for(high = 0; high <= nx; high++)
      132: 3814:	for(low = 0; low <= high; low++)
      264: 3815:	    {
      132: 3816:		chany_place_cost_fac[high][low] = (high - low + 1.) /
        -: 3817:		    chany_place_cost_fac[high][low];
        -: 3818:		chany_place_cost_fac[high][low] =
        2: 3819:		    pow((double)chany_place_cost_fac[high][low],
        -: 3820:			(double)place_cost_exp);
        -: 3821:	    }
        -: 3822:}
function check_place called 2 returned 100% blocks executed 70%
        2: 3823:
        -: 3824:
        -: 3825:static void
        -: 3826:check_place(float bb_cost,
        -: 3827:	    float timing_cost,
        -: 3828:	    int place_cost_type,
        -: 3829:	    int num_regions,
        -: 3830:	    enum e_place_algorithm place_algorithm,
        -: 3831:	    float delay_cost)
        -: 3832:{
        -: 3833:
        -: 3834:    /* Checks that the placement has not confused our data structures. *
        -: 3835:     * i.e. the clb and block structures agree about the locations of  *
        -: 3836:     * every block, blocks are in legal spots, etc.  Also recomputes   *
        -: 3837:     * the final placement cost from scratch and makes sure it is      *
        2: 3838:     * within roundoff of what we think the cost is.                   */
        -: 3839:
        -: 3840:    static int *bdone;
        -: 3841:    int i, j, k, error = 0, bnum;
        -: 3842:    float bb_cost_check;
        2: 3843:    int usage_check;
call    0 returned 100%
        2: 3844:    float timing_cost_check, delay_cost_check;
call    0 returned 100%
        2: 3845:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3846:    bb_cost_check = comp_bb_cost(CHECK, place_cost_type, num_regions);
    #####: 3847:    printf("bb_cost recomputed from scratch is %g.\n", bb_cost_check);
call    0 never executed
        -: 3848:    if(fabs(bb_cost_check - bb_cost) > bb_cost * ERROR_TOL)
        -: 3849:	{
    #####: 3850:	    printf
        -: 3851:		("Error:  bb_cost_check: %g and bb_cost: %g differ in check_place.\n",
        -: 3852:		 bb_cost_check, bb_cost);
        2: 3853:	    error++;
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
        -: 3854:	}
        -: 3855:
        2: 3856:    if(place_algorithm == NET_TIMING_DRIVEN_PLACE ||
call    0 returned 100%
        2: 3857:       place_algorithm == PATH_TIMING_DRIVEN_PLACE)
call    0 returned 100%
        -: 3858:	{
        4: 3859:	    comp_td_costs(&timing_cost_check, &delay_cost_check);
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        2: 3860:	    printf("timing_cost recomputed from scratch is %g. \n",
        -: 3861:		   timing_cost_check);
    #####: 3862:	    if(fabs(timing_cost_check - timing_cost) >
call    0 never executed
        -: 3863:	       timing_cost * ERROR_TOL)
        -: 3864:		{
    #####: 3865:		    printf("Error:  timing_cost_check: %g and timing_cost: "
        -: 3866:			   "%g differ in check_place.\n",
        2: 3867:			   timing_cost_check, timing_cost);
call    0 returned 100%
        -: 3868:		    error++;
        2: 3869:		}
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3870:	    printf("delay_cost recomputed from scratch is %g. \n",
    #####: 3871:		   delay_cost_check);
call    0 never executed
        -: 3872:	    if(fabs(delay_cost_check - delay_cost) > delay_cost * ERROR_TOL)
        -: 3873:		{
    #####: 3874:		    printf("Error:  delay_cost_check: %g and delay_cost: "
        -: 3875:			   "%g differ in check_place.\n",
        -: 3876:			   delay_cost_check, delay_cost);
        -: 3877:		    error++;
        2: 3878:		}
call    0 returned 100%
      278: 3879:	}
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      276: 3880:
        -: 3881:    bdone = (int *)my_malloc(num_blocks * sizeof(int));
        -: 3882:    for(i = 0; i < num_blocks; i++)
       26: 3883:	bdone[i] = 0;
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
      312: 3884:
branch  0 taken 92%
branch  1 taken 8% (fallthrough)
        -: 3885:    /* Step through grid array. Check it against block array. */
      288: 3886:    for(i = 0; i <= (nx + 1); i++)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3887:	for(j = 0; j <= (ny + 1); j++)
    #####: 3888:	    {
call    0 never executed
        -: 3889:		if(grid[i][j].usage > grid[i][j].type->capacity)
    #####: 3890:		    {
    #####: 3891:			printf
        -: 3892:			    ("Error:  block at grid location (%d,%d) overused. "
      288: 3893:			     "Usage is %d\n", i, j, grid[i][j].usage);
      722: 3894:			error++;
branch  0 taken 60%
branch  1 taken 40% (fallthrough)
        -: 3895:		    }
      434: 3896:		usage_check = 0;
      434: 3897:		for(k = 0; k < grid[i][j].type->capacity; k++)
branch  0 taken 36% (fallthrough)
branch  1 taken 64%
      158: 3898:		    {
        -: 3899:			bnum = grid[i][j].blocks[k];
      276: 3900:			if(EMPTY == bnum)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3901:			    continue;
    #####: 3902:
call    0 never executed
        -: 3903:			if(block[bnum].type != grid[i][j].type)
        -: 3904:			    {
    #####: 3905:				printf
        -: 3906:				    ("Error:  block %d type does not match grid location (%d,%d) type.\n",
      276: 3907:				     bnum, i, j);
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 0% (fallthrough)
branch  3 taken 100%
        -: 3908:				error++;
    #####: 3909:			    }
call    0 never executed
        -: 3910:			if((block[bnum].x != i) || (block[bnum].y != j))
        -: 3911:			    {
    #####: 3912:				printf
        -: 3913:				    ("Error:  block %d location conflicts with grid(%d,%d)"
      276: 3914:				     "data.\n", bnum, i, j);
      276: 3915:				error++;
        -: 3916:			    }
      288: 3917:			++usage_check;
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3918:			bdone[bnum]++;
    #####: 3919:		    }
call    0 never executed
        -: 3920:		if(usage_check != grid[i][j].usage)
    #####: 3921:		    {
        -: 3922:			printf
        -: 3923:			    ("Error:  Location (%d,%d) usage is %d, but has actual usage %d.\n",
        -: 3924:			     i, j, grid[i][j].usage, usage_check);
        -: 3925:		    }
      278: 3926:	    }
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
      276: 3927:
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -: 3928:    /* Check that every block exists in the grid and block arrays somewhere. */
    #####: 3929:    for(i = 0; i < num_blocks; i++)
call    0 never executed
        -: 3930:	if(bdone[i] != 1)
    #####: 3931:	    {
    #####: 3932:		printf
        -: 3933:		    ("Error:  block %d listed %d times in data structures.\n",
        2: 3934:		     i, bdone[i]);
        -: 3935:		error++;
        2: 3936:	    }
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
        -: 3937:    free(bdone);
        2: 3938:
call    0 returned 100%
        -: 3939:    if(error == 0)
        -: 3940:	{
        -: 3941:	    printf
        -: 3942:		("\nCompleted placement consistency check successfully.\n\n");
        -: 3943:#ifdef PRINT_REL_POS_DISTR
        -: 3944:	    print_relative_pos_distr();
        -: 3945:#endif
    #####: 3946:	}
call    0 never executed
        -: 3947:    else
        -: 3948:	{
    #####: 3949:	    printf
call    0 never executed
    #####: 3950:		("\nCompleted placement consistency check, %d Errors found.\n\n",
        -: 3951:		 error);
        2: 3952:	    printf("Aborting program.\n");
        -: 3953:	    exit(1);
        -: 3954:	}
        -: 3955:}
